  <!DOCTYPE html>
  <html lang="en-us">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">


    <meta name="generator" content="Source Themes Academic 4.6.0">
    <meta name="author" content="Wilson E. Marcílio Júnior">
    
    <meta name="description" content="RADAR COVID-19 - UNESP atuando no mapeamento de Casos de Coronavírus no interior paulista.">
    <link rel="alternate" hreflang="en-us" href="/coronavirus/">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.2/css/bootstrap.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta.2/js/bootstrap.bundle.min.js"></script> -->

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script>

    <meta name="theme-color" content="#2962ff">  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css" crossorigin="anonymous" title="hl-light">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
    
    
    <link rel="stylesheet" href="/css/academic.css">

    




    


    
    <link rel="alternate" href="index.xml" type="application/rss+xml" title="RADAR COVID-19">
    

    <link rel="manifest" href="index.webmanifest">
    <link rel="icon" type="image/png" href="/img/radar-icon.jpg">
    <link rel="apple-touch-icon" type="image/png" href="/img/radar-icon.jpg">

    <link rel="canonical" href="./">

    
    
    
    
      
      
    
    
    <meta property="twitter:card" content="summary">
    
    <meta property="og:site_name" content="RADAR COVID-19">
    <meta property="og:url" content="./">
    <meta property="og:title" content="RADAR COVID-19 - UNESP atuando no mapeamento de Casos de Coronavírus no interior paulista.">
    <meta property="og:description" content="UNESP atuando no mapeamento de Casos de Coronavírus no interior paulista."><meta property="og:image" content="/img/radar-icon.png">
    <meta property="twitter:image" content="/img/radar-icon.png"><meta property="og:locale" content="en-us">
    
      
    

    
    <script type="text/javascript" src="js/disjoint-sets.js"></script>
    <script type="text/javascript" src="js/javascript.util.min.js"></script>
    <script type="text/javascript" src="js/jsts.min.js"></script>

    <script src="https://rawgit.com/w8r/GreinerHormann/master/dist/greiner-hormann.min.js"></script>
    
    <meta property="twitter:card" content="summary">
    
    <meta property="og:site_name" content="RADAR COVID-19">
    <meta property="og:url" content="./">
    <meta property="og:title" content="RADAR COVID-19 - UNESP atuando no mapeamento de Casos de Coronavírus no interior paulista.">
    <meta property="og:description" content="UNESP atuando no mapeamento de Casos de Coronavírus no interior paulista."><meta property="og:image" content="/img/radar-icon.png">
    <meta property="twitter:image" content="/img/radar-icon.png"><meta property="og:locale" content="en-us">
    
      

   

    




    


    





    <title>Radar COVID-19</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162664785-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-162664785-1');
    </script>


    <script type="text/javascript" src="js/d3.js"></script>


    <style type="text/css">
      
      div.tooltip { 
            position: absolute;     
            text-align: center;     
            width: 120px;          
            height: 120px;         
            padding: 2px;       
            font: 13px sans-serif;    
            background: #fff; 
            border: 1px; 
            border-color: 'black';       
            pointer-events: none;     
      }   

      .overlay {
        fill: none;
        pointer-events: all;
    }

    .focus circle {
        fill: steelblue;
    }

    .focus text {
        font-size: 14px;
    }

    .tooltip2 {
        fill: white;
        stroke: #000;
    }

    .tooltip-date, .tooltip-likes, .tooltip-confirmados {
        font-weight: bold;
    }

      .title {
          /*font-family: "Times New Roman";*/
          font: 12px;
      }

      .department {
          /*font-family: "Lucida Console", Courier, monospace;*/
          font: 10px;
      }

       .numbers {
          font-family: "Lucida Console", Courier, monospace;
          font: 12px;
      }


       .ticks {
          font-family: "Lucida Console", Courier, monospace;
          font: 16px;
      }

      .note {
          font-family: "Lucida Console", Courier, monospace;
          font: 6px;
      }

      svg {
          border: 1px solid #dfe7f5;
      }

      .column {
      float: left;
      width: 50%;
      padding: 5px;
    }

    /* Clearfix (clear floats) */
    .row::after {
      content: "";
      clear: both;
      display: table;
    }

    .grid line {
      stroke: lightgrey;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }

    .grid path {
      stroke-width: 0;
    }

    .dropdown {
      margin-right: 80%;
    }

    .dropdown-menu {
      max-height: 20rem;
      overflow-y: auto;
    }

    </style>

  </head>

  <body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

    

    <aside class="search-results" id="search">
    <div class="container">
      <section class="search-header">

        <div class="row no-gutters justify-content-between mb-3">
          <div class="col-6">
            <h1>Search</h1>
          </div>
          <div class="col-6 col-search-close">
            <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
          </div>
        </div>

        <div id="search-box">
          
          <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
          autocomplete="off" autocorrect="off" spellcheck="false" type="search">
          
        </div>

      </section>
      <section class="section-search-results">

        <div id="search-hits">
          
        </div>

      </section>
    </div>
  </aside>


  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container">

      
      
      
        <a class="navbar-brand" href="/">Radar COVID-19</a>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          
          <li class="nav-item">
            <a class="nav-link " href="https://www.fct.unesp.br/"><span>FCT - UNESP</span></a>
          </li>


          <li class="nav-item">
            <a class="nav-link active" href="/data-mining/"><span>Análise de Rumores</span></a>
          </li>

          <li class="nav-item">
            <a class="nav-link active" href="/inspecao-hierarquica/"><span>Análise da Disseminação Hierárquica</span></a>
          </li>

          <li>
            <a class="nav-link active" href="/difusao-espacial/"><span>Difusão Espacial</span></a>
          </li>

          <li>
            <a class="nav-link active" href="/mapeamento-cartografico/"><span>Mapeamento Cartográfico</span></a>
          </li>

        </ul>
      </div>

      <!-- <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
      </ul> -->

    </div>
  </nav>  


  <!-- COLOCAR NO MAPA O SIMBOLO DA UNESP -->

    
  <div class="universal-wrapper pt-3">
    
    <!-- <h1 style="text-align: center; width:100%;">RADAR COVID-19</h1> -->
  <!--   <div style="text-align: center; width:100%;">
      
    </div> -->
    <h3 style="text-align: center; width:100%;">Análise da Disseminação Hierárquica de COVID-19 no Estado de São Paulo.</h3><br/>
    <img src="radar-icon.jpg" width="300" height="300" style="display: block;
    margin-left: auto;
    margin-right: auto;" />
    <ul>
      <ul>
        <li><a href="#analise-risco">Análise de risco de contaminação</a><br/></a></li>
        <li><a href="#pessoas-envolvidas"> Pesquisadores envolvidos</a></li>
      </ul>
      
    </ul>

    
  </div>

  <div id="analise-risco" class="container justify-content-between" style="margin: 10px!important;" >
        <div class="row"  style="width: 90vw!important;" >
           <div class="col-sm-6">
            
            <div class="dropdown">
                <h4>Análise de risco </h4> <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdown_cidades" data-toggle="dropdown" aria-haspopup="true"
                    aria-expanded="false">
                    Cidade
                </button>
                <div id="menu" class="dropdown-menu" aria-labelledby="dropdown_cidades">
                    <label for="#searchCidade">Selecione uma cidade: </label>
                    <input type="search" class="form-control" id="searchCidade" placeholder="Presidente Prudente" autofocus="autofocus">
                    <div id="menuItems"></div>
                    <div id="empty" class="dropdown-header">Cidade não encontrada</div>
                </div>
            </div>
            <br>
            <div>
              <svg id="cityRisk">
              </svg>
            </div>
            <button id="decreaseDay" name="decreaseDay"> << </button>
            <button id="increaseDay" name="increaseDay" disabled="true"> >> </button>
          </div>
          <div class="col-sm-6" style="margin-top: 90px">
            <h4 id="analise-visual">Mapa para refência.</h4>
            <div>
              <svg id="map-covid">        
                <!-- <foreignobject class="node" x="700" y="5" width="300" height="150">                
                    <label id="titleProgression" class="title">Dia: 25/Fevereiro</label><br/>
                    <button id="progression-back"><<</button> <button id="progression-front" style="margin-left: 10px;">>></button> <br>
                    <input type="range" id="realProgression" name="realProgression" class="progressionRange" value="0">   
                </foreignobject> -->

              </svg>
            </div>
          </div>
        </div>
  </div> 


  <div class="universal-wrapper">

    
    <br/>

    
     

    <div class="mainView">

      

      <!--
      <h4 id="casos-confirmados-color">KNN para difusão hierárquica - Cores.</h4>
       <div>
        <svg id="map-covid-color">        
          <foreignobject class="node" x="700" y="5" width="300" height="150">                
              <label id="titleProgressionColor" class="title">Dia: 25/Fevereiro</label><br/>
              <button id="progression-back-color"><<</button>     <button id="progression-front-color" style="margin-left: 10px;">>></button> <br>
              <input type="range" id="realProgressionColor" name="realProgressionColor" class="progressionRangeColor" value="0">   
          </foreignobject>

        </svg>
      </div>

      <br/>
      <br/>

      <h4 id="casos-confirmados">KNN para difusão hierárquica - Áreas em perigo.</h4>
      <div>
        <svg id="map-covid-danger">        
          <foreignobject class="node" x="700" y="5" width="300" height="150">                
              <label id="titleProgressionDanger" class="title">Dia: 25/Fevereiro</label><br/>
              <button id="progression-back-danger"><<</button>     <button id="progression-front-danger" style="margin-left: 10px;">>></button> <br>
              <input type="range" id="realProgressionDanger" name="realProgressionDanger" class="progressionRangeDanger" value="0">   
          </foreignobject>

        </svg>
      </div>

      <br/>
      <br/>

      <h4 id="casos-confirmados">KNN para difusão hierárquica - ConvexHull.</h4>
      <div>
        <svg id="map-covid-hull">        
          <foreignobject class="node" x="700" y="5" width="300" height="150">                
              <label id="titleProgressionHull" class="title">Dia: 25/Fevereiro</label><br/>
              <button id="progression-back-hull"><<</button>     <button id="progression-front-hull" style="margin-left: 10px;">>></button> <br>
              <input type="range" id="realProgressionHull" name="realProgressionHull" class="progressionRangeHull" value="0">   
          </foreignobject>

        </svg>
      </div>

      <br/>
      <br/>

      <h4>Gráfico 1: Evolução dos casos confirmados de COVID-19 no Estado de São Paulo.</h4>
      <div>
        <svg id="statisticalCharts"></svg>
      </div>

      <br/>
      <br/>

      <h4>Gráfico 2: Taxa de mortalidade no Estado de São Paulo.</h4>
      <div>
        <svg id="taxaMortalidade"></svg>
      </div>

      <br/>
      <br/>

      <h4 id="mapeamento-twitter">Mapa Interativo 2: Mineração dos <em>tweets</em> representando rumores dos sintomas de COVID-19.</h4>
      <div>
        <svg id="map-twitter">        
          <foreignobject class="node" x="700" y="5" width="300" height="150">                
              <label id="progressionTwitter" class="title">Dia: 07/Abril</label><br/>
              <button id="twitter-back"><<</button>     <button id="twitter-front" style="margin-left: 10px;">>></button> <br>

              <input type="range" id="dateTwitter" name="dateTwitter" class="progressionRange" value="0">   
          </foreignobject>

        </svg>
      </div>

      <br/>
      <br/>


      <h4>Gráfico 3: Evolução dos rumores de COVID-19 considerando <em>tweets</em> dos sintomas.</h4>
      <div>
        <svg id="statisticalChartsTwitter"></svg>
      </div>

      <br/>
      <br/>


      <h4>Gráfico 4: Análise </h4>
      <div>
        <svg id="statisticalChartsTwitterCity"></svg>
      </div>

      <br/>
      <br/> 

      <h4>Gráfico 5: Mapa</h4>
      <div>
        
        <svg id="mapAnalysis"></svg>
        <button id="nextDate">>></button>
      </div>


      <br/>
      <br/>

      <h4 id="mapeamento-google">Mapa Interativo 3: Resultados de pesquisas no Google considerando os sintomas de COVID-19.</h4>
      <div>
        <svg id="map-google">
            <foreignobject class="node" x="727" y="230" width="200" height="150">                
                 <label id="progressionGoogleTrends" class="title">Dia: 07/Abril</label><br/>
                 <button id="google-back"><<</button>     <button id="google-front" style="margin-left: 10px;">>></button> <br>
                 <input type="range" id="dateGoogleTrends" name="dateGoogleTrends" class="progressionRange" value="0">
            </foreignobject>
        </svg>
      </div>


      <h4>Gráfico 4: Evolução de pesquisas no Google considerando os sintomas de COVID-19.</h4>
      <div>
        <script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2152_RC02/embed_loader.js"></script> <script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"tosse","geo":"BR-SP","time":"today 1-m"},{"keyword":"febre","geo":"BR-SP","time":"today 1-m"},{"keyword":"tosse seca","geo":"BR-SP","time":"today 1-m"},{"keyword":"febre alta","geo":"BR-SP","time":"today 1-m"},{"keyword":"falta de ar","geo":"BR-SP","time":"today 1-m"}],"category":0,"property":""}, {"exploreQuery":"date=today%201-m&geo=BR-SP&q=tosse,febre,tosse%20seca,febre%20alta,falta%20de%20ar","guestPath":"https://trends.google.com:443/trends/embed/"}); 
        </script> 
      </div>



      -->


    </div>
  </div>

  <div class="universal-wrapper" id="video-explicacao">
      
<!-- 
      <div class="mainView">
        <h4>Explicação do modelo de interpretação hierárquica da disseminação do COVID-19.</h4>
        <div>
          <iframe width="100%" height="650px" src="https://youtube.com/embed/fQIu5Pma6io">
          </iframe>
        </div>
      </div>

       -->

  </div>

    <div class="universal-wrapper" id="pessoas-envolvidas">

      
      <h1>Pesquisadores envolvidos</h1>  

      



      <div class="media author-card content-widget-hr">
          
            
          <img class="portrait mr-3" src="/authors/admin/rogerio.jpg" alt="Avatar">
          

          <div class="media-body">
            <h5 class="card-title"><a href="#">Prof. Dr. Rogério Eduardo Garcia</a></h5>
            <h6 class="card-subtitle">Departamento de Matemática e Computação - FCT/UNESP</h6>
            <ul class="network-icon" aria-hidden="true">
                  <li>
                    <a href="mailto:rogerio.garcia@unesp.com" >
                      <i class="fas fa-envelope"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://www.researchgate.net/profile/Rogerio_Garcia" target="_blank" rel="noopener">
                      <i class="ai ai-researchgate"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://scholar.google.com.br/citations?user=F6DXOMQAAAAJ" target="_blank" rel="noopener">
                      <i class="ai ai-google-scholar"></i>
                    </a>
                  </li>
                
                  <li>
                    <a href="https://orcid.org/0000-0003-1248-528X" target="_blank" rel="noopener">
                      <i class="ai ai-orcid"></i>
                    </a>
                  </li>             
            </ul>

          </div>
      </div>

      <div class="media author-card content-widget-hr">
          
            
          <img class="portrait mr-3" src="/authors/admin/danilo.jpg" alt="Avatar">
          

          <div class="media-body">
            <h5 class="card-title"><a href="#">Prof. Dr. Danilo Medeiros Eler</a></h5>
            <h6 class="card-subtitle">Departamento de Matemática e Computação - FCT/UNESP</h6>
            <ul class="network-icon" aria-hidden="true">
                  <li>
                    <a href="mailto:danilo.eler@unesp.com" >
                      <i class="fas fa-envelope"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://www.researchgate.net/profile/Danilo_Eler" target="_blank" rel="noopener">
                      <i class="ai ai-researchgate"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://scholar.google.com.br/citations?user=p5mxNX8AAAAJ" target="_blank" rel="noopener">
                      <i class="ai ai-google-scholar"></i>
                    </a>
                  </li>
                
                  <li>
                    <a href="http://orcid.org/0000-0002-9493-145X" target="_blank" rel="noopener">
                      <i class="ai ai-orcid"></i>
                    </a>
                  </li>

                  <li>
                    <a href="https://github.com/daniloeler" target="_blank" rel="noopener">
                      <i class="fab fa-github"></i>
                    </a>
                  </li>
                
            </ul>

          </div>
      </div>

      <div class="media author-card content-widget-hr">
          
            
          <img class="portrait mr-3" src="/authors/admin/ronaldo.jpg" alt="Avatar">
          

          <div class="media-body">
            <h5 class="card-title"><a href="#">Prof. Dr. Ronaldo Celso Messias Correia</a></h5>
            <h6 class="card-subtitle">Departamento de Matemática e Computação - FCT/UNESP</h6>
            <ul class="network-icon" aria-hidden="true">
                  <li>
                    <a href="mailto:ronaldo.correia@unesp.br" >
                      <i class="fas fa-envelope"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://www.researchgate.net/profile/Ronaldo_Correia" target="_blank" rel="noopener">
                      <i class="ai ai-researchgate"></i>
                    </a>
                  </li>
              
                  <!-- <li>
                    <a href="https://scholar.google.com/citations?user=-KvJBfcAAAAJ" target="_blank" rel="noopener">
                      <i class="ai ai-google-scholar"></i>
                    </a>
                  </li> -->
                
                  <li>
                    <a href="http://orcid.org/0000-0002-8044-7333" target="_blank" rel="noopener">
                      <i class="ai ai-orcid"></i>
                    </a>
                  </li>
              
            </ul>

          </div>
      </div>

      <div class="media author-card content-widget-hr">
          
            
          <img class="portrait mr-3" src="/authors/admin/avatar_hue102bab58b683d05ea725ccd34a293b1_11390_250x250_fill_q90_lanczos_center.jpg" alt="Avatar">
          

          <div class="media-body">
            <h5 class="card-title"><a href="#">MSc. Wilson Estécio Marcílio Júnior</a></h5>
            <h6 class="card-subtitle">Doutorando em Ciência da Computação</h6>
            <ul class="network-icon" aria-hidden="true">
                  <li>
                    <a href="mailto:wilson.marcilio@unesp.com" >
                      <i class="fas fa-envelope"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://www.researchgate.net/profile/Wilson_Estecio_Marcilio_Junior" target="_blank" rel="noopener">
                      <i class="ai ai-researchgate"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://scholar.google.com/citations?user=-KvJBfcAAAAJ" target="_blank" rel="noopener">
                      <i class="ai ai-google-scholar"></i>
                    </a>
                  </li>
                
                  <li>
                    <a href="https://orcid.org/0000-0002-8580-2779" target="_blank" rel="noopener">
                      <i class="ai ai-orcid"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://github.com/wilsonjr" target="_blank" rel="noopener">
                      <i class="fab fa-github"></i>
                    </a>
                  </li>       
            </ul>

          </div>
      </div>


      <div class="media author-card content-widget-hr">
          
            
          <img class="portrait mr-3" src="/authors/admin/rafael.jpg" alt="Avatar">
          

          <div class="media-body">
            <h5 class="card-title"><a href="#">Rafael Bezerra de Menezes Rodrigues</a></h5>
            <h6 class="card-subtitle">Mestrando em Ciência da Computação</h6>
            <ul class="network-icon" aria-hidden="true">
                  <li>
                    <a href="mailto:rafael.rodrigues@unesp.br" >
                      <i class="fas fa-envelope"></i>
                    </a>
                  </li>
              
                 <!--  <li>
                    <a href="https://www.researchgate.net/profile/Wilson_Estecio_Marcilio_Junior" target="_blank" rel="noopener">
                      <i class="ai ai-researchgate"></i>
                    </a>
                  </li>
              
                  <li>
                    <a href="https://scholar.google.com/citations?user=-KvJBfcAAAAJ" target="_blank" rel="noopener">
                      <i class="ai ai-google-scholar"></i>
                    </a>
                  </li>
                
                  <li>
                    <a href="https://orcid.org/0000-0002-8580-2779" target="_blank" rel="noopener">
                      <i class="ai ai-orcid"></i>
                    </a>
                  </li> -->
              
                  <li>
                    <a href="https://github.com/RafaelBMR" target="_blank" rel="noopener">
                      <i class="fab fa-github"></i>
                    </a>
                  </li>       
            </ul>

          </div>
      </div>

      <div class="article-widget content-widget-hr">
      <h3>Dados</h3>
      <ul>
        
        <li><a href="https://github.com/wcota/covid19br"> COVID19BR</a></li>
        <li><a href="https://www.seade.gov.br/coronavirus/"> SEADE</a></li>
        
      </ul>
    </div>
  </div>


  

  </div>



  </div>


  

      <script type="text/javascript">


        let tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .attr('id', 'tooltip')
            .style('opacity', 0);

        let unesps = ['Araçatuba','Araraquara','Assis','Bauru','Botucatu','Dracena','Franca','Guaratinguetá','Ilha Solteira','Itapeva','Jaboticabal','Marília','Ourinhos','Presidente Prudente','Registro','Rio Claro','Rosana','São João da Boa Vista','São José do Rio Preto','São José dos Campos','São Paulo','São Vicente','Sorocaba','Tupã'];

        for (var i = 0; i < unesps.length; i++) {
            unesps[i] = unesps[i].replace(/[^\x00-\x7F]/g, "");
        }

        let width = 900;
        let height = 750;

        let aggregate = false;


        let casosByCity = null;
        let googleTrendsMap = null;
        let colors = null;
        let colorTrends = null;
        let termTrends = null;
        let subsetGoogleTrendsMap = null;
        let allTweets = null;
        let cityById = null;
        let cityQuantity = null;
        let cityQuantityVector = null;


        let maxAggregateTweets = 0;
        let firstDayAnalysis = null;
        let lastDayAnalysis = null;

        let googleDayMax = 0;
        let googleDay = 0;

        let progressionDayMax = 0;
        let progressionDay = 0;

        let progressionDayMaxColor = 0;
        let progressionDayColor = 0;

        let progressionDayMaxHull = 0;
        let progressionDayHull = 0;

        let progressionDayMaxDanger = 0;
        let progressionDayDanger = 0;

        let twitterDayMax = 0;
        let twitterDay = 0;

        let mapCityCount = null;


        let cities =null;
        let dates =null;
        let values =null;


        let accumulated_tweets =null;
        let accumulated_cases =null;
        let accumulated_tweets_city =null;


        let max_casos =null;
        let max_tweets = null;

        let reversed_knn = null;
        let risk_data = null;


        let store = {};

        let currentDate = 0;

        let window_analysis = 10;
        let dayAnalysis = null;
        let cityAnalysis = null;

        let months = {
            '0': 'January',
            '1': 'February',
            '2': 'March',
            '3': 'April',
            '4': 'May',
            '5': 'June',
            '6': 'July',
            '7': 'August',
            '8': 'September',
            '9': 'October',
            '10': 'November',
            '11': 'December'
        };

        let map_month = {
            'fev': 2,
            'mar': 3,
            'abr': 4,
            'mai': 5,
            'jun': 6,
            'jul': 7,
            'ago': 8,
            'set': 9,
            'out': 10,
            'nov': 11,
            'dez': 12
        };

        let map_month_pt = {
            'fev': 'Fevereiro',
            'mar': 'Março',
            'abr': 'Abril',
            'mai': 'Maio',
            'jun': 'Junho',
            'jul': 'Julho',
            'ago': 'Agosto',
            'set': 'Setembro',
            'out': 'Outubro',
            'nov': 'Novembro',
            'dez': 'Dezembro'
        };

        let number_to_month = {
          0: 'jan',
          1: 'fev',
          2: 'mar',
          3: 'abr',
          4: 'mai',
          5: 'jun',
          6: 'jul',
          7: 'ago',
          8: 'set',
          9: 'out',
          10: 'nov',
          11: 'dez'
        };

        let knn_cities = null;

        let accumulated_days = null;

        let showingTooltip = false;

        let neighboring_cities = null, previous_neighboring_cities = [];
        let neighboring_cities_danger = null, previous_neighboring_danger_cities = [];

        let configMapRealHull = null;
        let projectionMapRealHull = null;
        let geoJsonHull = null;

        let configMapRealDanger = null;
        let projectionMapRealDanger = null;
        let geoJsonDanger = null;

        let configMapReal = null;
        let projectionMapReal = null;
        let geoJson = null;

        let configMapRealColor = null;
        let projectionMapRealColor = null;
        let geoJsonColor = null;

        let kFirstLevel = 10;
        let kSecondLevel = 5;

        let currentAnalysisLine = 0;
        let currentAnalysisColumn = 0;

        let MAX_ANALYSIS_LINE = 4;
        let MAX_ANALYSIS_COLUMN = 1;


        // let ks = prompt("K1 e K2 separados por espaço (K2 <= K1)");
        kFirstLevel = 10;// +ks.split(" ")[0];
        kSecondLevel = 5;//Math.min(kFirstLevel, +ks.split(" ")[0]);
        let d = prompt('Dias de análise');

        window_analysis = +d;

        // loadData();
        loadData().then(showData);

        function drawBaseMapRealDanger(container, countries, projection, geoJson, subset, update) {
            let backup = null;

            if( subset != null ) {
                backup = casosByCity;
                casosByCity = subset;
            } else {

                backup = casosByCity;

                // casosByCity = backup.filter(d => d.date.getTime() == lastDate.getTime());
                casosByCity = backup.filter(d => d.date.getTime() == casosByCity[0].date.getTime())
            }

            current = casosByCity;
            let max_casos = d3.max(casosByCity, d => d.casos);


            let path = d3.geoPath()
                .projection(projection);

            if( !update ) {
                container.selectAll('path')
                    .data(countries)
                    .enter().append('path')
                    .attr('d', d => { return path(d); })
                    .on('click', d => {

                      // if( showingTooltip ) {
                      //   tooltip.transition()
                      //       .duration(500)
                      //       .style('opacity', 0);
                      // } else {
                          let value = 0;
    
                          let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
    
                          for (var i = 0; i < current.length; i++) {
                              let cityName = current[i]['cidade'].replace(/[^\x00-\x7F]/g, "");
                              if( cityName.trim() == name.trim() ) {
                                  value = current[i]['casos'];
                                  break;
                              }
                          }
                          tooltip.html("<p>"+d.properties.name+"</p>"+
                                      "<p>"+value+" caso(s) confirmados.</p>")
                              .style('left', (d3.event.pageX)+'px')
                              .style('top', (d3.event.pageY - 28)+'px');

                          let s = document.getElementById('tooltip').style;
                          s.opacity = 1;
                          function fade() {
                            (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                          }
                          fade();
                      // }
                      // showingTooltip = !showingTooltip;
                    })
                    // .on('mouseout', d => {
                        
                    // });


            } 
            
            let filtered_current = current.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") in knn_cities);
            // container.selectAll('path').remove();
            let citiesWithCases = filtered_current.map(d => d.cidade.replace(/[^\x00-\x7F]/g, ""));

            
            neighboring_cities_danger = [];

            for( let i = 0; i < filtered_current.length; ++i ) {
                let name_current = filtered_current[i].cidade.replace(/[^\x00-\x7F]/g, "");
                let values = getKNN(name_current);

                for( let j = 0; j < values.length; ++j ) {
                  let name_knn = values[j].replace(/[^\x00-\x7F]/g, "");
                  if( (citiesWithCases.indexOf(name_knn) == -1) )
                    neighboring_cities_danger.push(name_knn);
                }
            } 

            // console.log('previous_neighboring_cities');
            // console.log(previous_neighboring_danger_cities);
            // console.log('neighboring_cities_danger');
            // console.log(neighboring_cities_danger);
            // console.log();

            container.selectAll('path')
              .transition()
              .duration(0)
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill', d => {
                    let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
                    if( neighboring_cities_danger.indexOf(name) != -1 )
                        return '#ffbb00';
                    else if( previous_neighboring_danger_cities != null && previous_neighboring_danger_cities.indexOf(name) != -1 ) {
                       // let ocurrences = previous_neighboring_danger_cities.reduce((a, b) => a + (b  == name ? 1 : 0), 0);
                       // console.log('number of ocurrences: ', ocurrences);
                       return '#ccc';
                    } else 
                        return '#fff';

                    // let value = 0;
                    // if( value == 0 )
                    //     return '#fff';

                    // return d3.interpolateReds(value/max_casos);
                })
                .style('fill-opacity', d => {
                    let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");

                    if( neighboring_cities_danger.indexOf(name) != -1 ){ 
                        let occurences = neighboring_cities_danger.reduce((a, b) => a + (b  == name ? 1 : 0), 0);
                         
                        return occurences*0.1;
                    } else if( previous_neighboring_danger_cities != null && previous_neighboring_danger_cities.indexOf(name) != -1 )
                        return 0.5;
                    else 
                        return 1;
                });

            let scaleArea = d3.scaleLog()
                .domain([1, d3.max(backup, d => +d.casos)])
                .range([5, 20]);

            let scaleArea2 = d3.scaleLog()
                .domain([1, Math.pow(Math.round(scaleArea.invert(25/2)), 2)])
                .range([5, 20])

            let scaleLegend = Math.pow(Math.round(scaleArea.invert(25/2)), 2) > d3.max(backup, d => +d.casos) ?
                              scaleArea : scaleArea2;


            let g = null, g_knn = null;
            if( !update ) {
                g = container.append('g')
                    .attr('class', 'real_cases');     

                g_knn = container.append('g')
                  .attr('class', 'knn_cases');

                let g_legend = container.append('g')
                    .attr('transform', 'translate(0,20)');   

                let max = 4;
                let step = (d3.max(backup, d => +d.casos) - d3.min(backup, d => +d.casos))/max;


                let numbers = [...new Set(backup.map(d =>  +d.casos))].sort(function compare(a, b) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                });
              
                let numbers_legend = [1,  Math.round(scaleArea.invert((20+5)/2)), Math.pow(Math.round(scaleArea.invert(25/2)), 2)];

                g_legend.append('circle')
                    .attr('cx', d => 15)
                    .attr('cy', d => 50)
                    .attr('r', scaleLegend(numbers_legend[0]))
                    .style('fill', '#eb4034')
                    .style('fill-opacity', 0.2)
                    .style('stroke', '#eb4034')
                    .style('stroke-opacity', 0.8);  

                g_legend.append('text')
                        .attr('x', d => 15)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text('1');
                
                let r_before = scaleLegend(numbers_legend[0]);
                let x_before = 15;

                for( let  i = 1; i < numbers_legend.length; i++ ) {

                    let r = scaleLegend(numbers_legend[i]);

                    g_legend.append('circle')
                        .attr('cx', d => x_before + r_before + 20 + r)
                        .attr('cy', d => 50)
                        .attr('r', r)
                        .style('fill', '#eb4034')
                        .style('fill-opacity', 0.2)
                        .style('stroke', '#eb4034')
                        .style('stroke-opacity', 0.8);  

                    g_legend.append('text')
                        .attr('x', d => x_before + r_before + 20 + r)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text(numbers_legend[i]);

                    r_before = r;
                    x_before = x_before + r_before + 20 + r;

                }
                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 20)
                  .style('font-size', 16)
                  .style('font-family', 'Helvetica')
                  .attr('text-anchor', 'start')
                  .text('CASOS CONFIRMADOS*');


                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 120)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('*Dimensionamento dos círculos:'); 

                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 130)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('Escala logarítmica.');  


                let g_description = container.append('g')
                    .attr('transform', 'translate(10,650)');   

                addUnespDescription(g_description);

            } else {
                g = container.select('.real_cases');
                container.select('.knn_cases').selectAll("*").remove();
                g_knn = container.select('.knn_cases');
            }

            
            
            let circle = g.selectAll('circle')
                .data(filtered_current, d => d.cidade);

            circle.exit().remove();

            circle.enter().append('circle')
                .attr('cx', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[0])// 
                .attr('cy', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[1])//
                .on('click', d => {
                    tooltip.html("<p>"+d.cidade+"</p>"+
                                "<p>"+d.casos+" caso(s) confirmados.</p>")
                        .style('left', (d3.event.pageX)+'px')
                        .style('top', (d3.event.pageY - 28)+'px');

                    let s = document.getElementById('tooltip').style;
                    s.opacity = 1;
                    function fade() {
                      (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                    }
                    fade();
                 })
                .style('fill', '#eb4034')
                .style('fill-opacity', 0.2)
                .style('stroke', '#eb4034')
                .style('stroke-opacity', 0.8)
              .merge(circle)
              .transition()
              .duration(500)
                  .attr('r', d => scaleArea(+d.casos));


            
                
            if( backup != null ) {
                casosByCity = backup;
            }
        }

        function drawBaseMapRealColor(container, countries, projection, geoJson, subset, update) {
            let backup = null;

            if( subset != null ) {
                backup = casosByCity;
                casosByCity = subset;
            } else {

                backup = casosByCity;

                // casosByCity = backup.filter(d => d.date.getTime() == lastDate.getTime());
                casosByCity = backup.filter(d => d.date.getTime() == casosByCity[0].date.getTime())
            }

            current = casosByCity;
            let max_casos = d3.max(casosByCity, d => d.casos);


            let path = d3.geoPath()
                .projection(projection);

            if( !update ) {
                container.selectAll('path')
                    .data(countries)
                    .enter().append('path')
                    .attr('d', d => { return path(d); })
                    .on('click', d => {

                      // if( showingTooltip ) {
                      //   tooltip.transition()
                      //       .duration(500)
                      //       .style('opacity', 0);
                      // } else {
                          let value = 0;
    
                          let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
    
                          for (var i = 0; i < current.length; i++) {
                              let cityName = current[i]['cidade'].replace(/[^\x00-\x7F]/g, "");
                              if( cityName.trim() == name.trim() ) {
                                  value = current[i]['casos'];
                                  break;
                              }
                          }
                          tooltip.html("<p>"+d.properties.name+"</p>"+
                                      "<p>"+value+" caso(s) confirmados.</p>")
                              .style('left', (d3.event.pageX)+'px')
                              .style('top', (d3.event.pageY - 28)+'px');

                          let s = document.getElementById('tooltip').style;
                          s.opacity = 1;
                          function fade() {
                            (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                          }
                          fade();
                      // }
                      // showingTooltip = !showingTooltip;
                    })
                    // .on('mouseout', d => {
                        
                    // });


            } 
            
            let filtered_current = current.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") in knn_cities);
            // container.selectAll('path').remove();
            let citiesWithCases = filtered_current.map(d => d.cidade.replace(/[^\x00-\x7F]/g, ""));

            
            neighboring_cities = [];

            for( let i = 0; i < filtered_current.length; ++i ) {
                let name_current = filtered_current[i].cidade.replace(/[^\x00-\x7F]/g, "");
                let values = getKNN(name_current);

                for( let j = 0; j < values.length; ++j ) {
                  let name_knn = values[j].replace(/[^\x00-\x7F]/g, "");
                  if( (citiesWithCases.indexOf(name_knn) == -1) )
                    neighboring_cities.push(name_knn);
                }
            } 



            container.selectAll('path')
              .transition()
              .duration(update ? 1000 : 0)
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill', d => {
                    let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");

                    if( neighboring_cities.indexOf(name) != -1 )
                        return '#ffbb00';
                    else if( previous_neighboring_cities != null && previous_neighboring_cities.indexOf(name) != -1 )
                        return '#3455eb';
                    else 
                        return '#fff';

                    // let value = 0;
                    // if( value == 0 )
                    //     return '#fff';

                    // return d3.interpolateReds(value/max_casos);
                });

            let scaleArea = d3.scaleLog()
                .domain([1, d3.max(backup, d => +d.casos)])
                .range([5, 20]);

            let scaleArea2 = d3.scaleLog()
                .domain([1, Math.pow(Math.round(scaleArea.invert(25/2)), 2)])
                .range([5, 20])

            let scaleLegend = Math.pow(Math.round(scaleArea.invert(25/2)), 2) > d3.max(backup, d => +d.casos) ?
                              scaleArea : scaleArea2;


            let g = null, g_knn = null;
            if( !update ) {
                g = container.append('g')
                    .attr('class', 'real_cases');     

                g_knn = container.append('g')
                  .attr('class', 'knn_cases');

                let g_legend = container.append('g')
                    .attr('transform', 'translate(0,20)');   

                let max = 4;
                let step = (d3.max(backup, d => +d.casos) - d3.min(backup, d => +d.casos))/max;


                let numbers = [...new Set(backup.map(d =>  +d.casos))].sort(function compare(a, b) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                });
              
                let numbers_legend = [1,  Math.round(scaleArea.invert((20+5)/2)), Math.pow(Math.round(scaleArea.invert(25/2)), 2)];

                g_legend.append('circle')
                    .attr('cx', d => 15)
                    .attr('cy', d => 50)
                    .attr('r', scaleLegend(numbers_legend[0]))
                    .style('fill', '#eb4034')
                    .style('fill-opacity', 0.2)
                    .style('stroke', '#eb4034')
                    .style('stroke-opacity', 0.8);  

                g_legend.append('text')
                        .attr('x', d => 15)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text('1');
                
                let r_before = scaleLegend(numbers_legend[0]);
                let x_before = 15;

                for( let  i = 1; i < numbers_legend.length; i++ ) {

                    let r = scaleLegend(numbers_legend[i]);

                    g_legend.append('circle')
                        .attr('cx', d => x_before + r_before + 20 + r)
                        .attr('cy', d => 50)
                        .attr('r', r)
                        .style('fill', '#eb4034')
                        .style('fill-opacity', 0.2)
                        .style('stroke', '#eb4034')
                        .style('stroke-opacity', 0.8);  

                    g_legend.append('text')
                        .attr('x', d => x_before + r_before + 20 + r)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text(numbers_legend[i]);

                    r_before = r;
                    x_before = x_before + r_before + 20 + r;

                }
                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 20)
                  .style('font-size', 16)
                  .style('font-family', 'Helvetica')
                  .attr('text-anchor', 'start')
                  .text('CASOS CONFIRMADOS*');


                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 120)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('*Dimensionamento dos círculos:'); 

                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 130)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('Escala logarítmica.');  


                let g_description = container.append('g')
                    .attr('transform', 'translate(10,650)');   

                addUnespDescription(g_description);

            } else {
                g = container.select('.real_cases');
                container.select('.knn_cases').selectAll("*").remove();
                g_knn = container.select('.knn_cases');
            }

            
            
            let circle = g.selectAll('circle')
                .data(filtered_current, d => d.cidade);

            circle.exit().remove();

            circle.enter().append('circle')
                .attr('cx', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[0])// 
                .attr('cy', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[1])//
                .on('click', d => {
                    tooltip.html("<p>"+d.cidade+"</p>"+
                                "<p>"+d.casos+" caso(s) confirmados.</p>")
                        .style('left', (d3.event.pageX)+'px')
                        .style('top', (d3.event.pageY - 28)+'px');

                    let s = document.getElementById('tooltip').style;
                    s.opacity = 1;
                    function fade() {
                      (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                    }
                    fade();
                 })
                .style('fill', '#eb4034')
                .style('fill-opacity', 0.2)
                .style('stroke', '#eb4034')
                .style('stroke-opacity', 0.8)
              .merge(circle)
              .transition()
              .duration(500)
                  .attr('r', d => scaleArea(+d.casos));


            
                
            if( backup != null ) {
                casosByCity = backup;
            }
        }

        function drawBaseMapReal(container, countries, projection, geoJson, subset, update, names_knn, influenced_city) {
            let backup = null;

            if( subset != null ) {
                backup = casosByCity;
                casosByCity = subset;
            } else {

                backup = casosByCity;

                // casosByCity = backup.filter(d => d.date.getTime() == lastDate.getTime());
                casosByCity = backup.filter(d => d.date.getTime() == casosByCity[0].date.getTime())
            }

            current = casosByCity;
            let max_casos = d3.max(casosByCity, d => d.casos);


            let path = d3.geoPath()
                .projection(projection);

            if( !update ) {
                container.selectAll('path')
                    .data(countries)
                    .enter().append('path')
                    .attr('d', d => { return path(d); })
                    .on('click', d => {

                      // if( showingTooltip ) {
                      //   tooltip.transition()
                      //       .duration(500)
                      //       .style('opacity', 0);
                      // } else {
                          let value = 0;
    
                          let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
    
                          for (var i = 0; i < current.length; i++) {
                              let cityName = current[i]['cidade'].replace(/[^\x00-\x7F]/g, "");
                              if( cityName.trim() == name.trim() ) {
                                  value = current[i]['casos'];
                                  break;
                              }
                          }
                          tooltip.html("<p>"+d.properties.name+"</p>"+
                                      "<p>"+value+" caso(s) confirmados.</p>")
                              .style('left', (d3.event.pageX)+'px')
                              .style('top', (d3.event.pageY - 28)+'px');

                          let s = document.getElementById('tooltip').style;
                          s.opacity = 1;
                          function fade() {
                            (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                          }
                          fade();
                      // }
                      // showingTooltip = !showingTooltip;

                          cityAnalysis = d.properties.name;
                          dayAnalysis = new Date(lastDayAnalysis.getTime());

                        
                          addRiskMeasures(d.properties.name.replace(/[^\x00-\x7F]/g, ""), d.properties.name, dayAnalysis, window_analysis);

                        
                        
                    })
                    // .on('mouseout', d => {
                        
                    // });


            } 
            
            let filtered_current = current.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") in knn_cities);

            let scaleColorRisk = d3.scaleSqrt()
              .domain([0, names_knn == null ? 1 : Math.max(d3.max(names_knn, d => d.casos), influenced_city.casos)])
              .range([0, 1]);
            console.log('names_knn, ',(names_knn == null ? '=]' : Math.max(d3.max(names_knn, d => d.casos), influenced_city.casos)))
          console.log(names_knn);
            container.selectAll('path')
              .transition()
              .duration(update ? 1000 : 0)
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill', d => {

                    let value = 0;

                    if( names_knn != null ) {
                      let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
                      if( name == influenced_city.name.replace(/[^\x00-\x7F]/g, "") )
                        value = influenced_city.casos;
                      else {

                        for( let i = 0; i < names_knn.length; ++i ) {
                          if( name == names_knn[i].name.replace(/[^\x00-\x7F]/g, "") ) {
                            value = names_knn[i].casos;
                            break;
                          }
                        }

                      }

                    }

                    if( value == 0 )
                        return '#fff';
                    return d3.interpolateReds(scaleColorRisk(value));
                });

            let scaleArea = d3.scaleLog()
                .domain([1, d3.max(backup, d => +d.casos)])
                .range([5, 20]);

            let scaleArea2 = d3.scaleLog()
                .domain([1, Math.pow(Math.round(scaleArea.invert(25/2)), 2)])
                .range([5, 20])

            let scaleLegend = Math.pow(Math.round(scaleArea.invert(25/2)), 2) > d3.max(backup, d => +d.casos) ?
                              scaleArea : scaleArea2;


            let g = null, g_knn = null;
            if( !update ) {
                g = container.append('g')
                    .attr('class', 'real_cases');     

                g_knn = container.append('g')
                  .attr('class', 'knn_cases');

                let g_legend = container.append('g')
                    .attr('transform', 'translate(0,20)');   

                // let max = 4;
                // let step = (d3.max(backup, d => +d.casos) - d3.min(backup, d => +d.casos))/max;


                // let numbers = [...new Set(backup.map(d =>  +d.casos))].sort(function compare(a, b) {
                //     if (a < b) return -1;
                //     if (a > b) return 1;
                //     return 0;
                // });
              
                // let numbers_legend = [1,  Math.round(scaleArea.invert((20+5)/2)), Math.pow(Math.round(scaleArea.invert(25/2)), 2)];

                // g_legend.append('circle')
                //     .attr('cx', d => 15)
                //     .attr('cy', d => 50)
                //     .attr('r', scaleLegend(numbers_legend[0]))
                //     .style('fill', '#eb4034')
                //     .style('fill-opacity', 0.2)
                //     .style('stroke', '#eb4034')
                //     .style('stroke-opacity', 0.8);  

                // g_legend.append('text')
                //         .attr('x', d => 15)
                //         .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                //         .attr('text-anchor', 'middle')
                //         .style('font-size', 16)
                //         .style('font-family', 'Helvetica')
                //         .text('1');
                
                // let r_before = scaleLegend(numbers_legend[0]);
                // let x_before = 15;

                // for( let  i = 1; i < numbers_legend.length; i++ ) {

                //     let r = scaleLegend(numbers_legend[i]);

                //     g_legend.append('circle')
                //         .attr('cx', d => x_before + r_before + 20 + r)
                //         .attr('cy', d => 50)
                //         .attr('r', r)
                //         .style('fill', '#eb4034')
                //         .style('fill-opacity', 0.2)
                //         .style('stroke', '#eb4034')
                //         .style('stroke-opacity', 0.8);  

                //     g_legend.append('text')
                //         .attr('x', d => x_before + r_before + 20 + r)
                //         .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                //         .attr('text-anchor', 'middle')
                //         .style('font-size', 16)
                //         .style('font-family', 'Helvetica')
                //         .text(numbers_legend[i]);

                //     r_before = r;
                //     x_before = x_before + r_before + 20 + r;

                // }
                // g_legend.append('text')
                //   .attr('x', d => 10)
                //   .attr('y', d => 20)
                //   .style('font-size', 16)
                //   .style('font-family', 'Helvetica')
                //   .attr('text-anchor', 'start')
                //   .text('CASOS CONFIRMADOS*');


                // g_legend.append('text')
                //   .attr('x', d => 10)
                //   .attr('y', d => 120)
                //   .attr('text-anchor', 'start')
                //   .style('font-size', 10)
                //   .style('font-family', 'Helvetica')
                //   .text('*Dimensionamento dos círculos:'); 

                // g_legend.append('text')
                //   .attr('x', d => 10)
                //   .attr('y', d => 130)
                //   .attr('text-anchor', 'start')
                //   .style('font-size', 10)
                //   .style('font-family', 'Helvetica')
                //   .text('Escala logarítmica.');  


                let g_description = container.append('g')
                    .attr('transform', 'translate(10,650)');   

                addUnespDescription(g_description);

            } else {
                g = container.select('.real_cases');
                container.select('.knn_cases').selectAll("*").remove();
                g_knn = container.select('.knn_cases');
            }

            
            
            // let circle = g.selectAll('circle')
            //     .data(filtered_current, d => d.cidade);

            // circle.exit().remove();

            // circle.enter().append('circle')
            //     .attr('cx', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[0])// 
            //     .attr('cy', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[1])//
            //     .on('click', d => {
            //         tooltip.html("<p>"+d.cidade+"</p>"+
            //                     "<p>"+d.casos+" caso(s) confirmados.</p>")
            //             .style('left', (d3.event.pageX)+'px')
            //             .style('top', (d3.event.pageY - 28)+'px');

            //         let s = document.getElementById('tooltip').style;
            //         s.opacity = 1;
            //         function fade() {
            //           (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
            //         }
            //         fade();
            //      })
            //     .style('fill', '#eb4034')
            //     .style('fill-opacity', 0.2)
            //     .style('stroke', '#eb4034')
            //     .style('stroke-opacity', 0.8)
            //   .merge(circle)
            //   .transition()
            //   .duration(500)
            //       .attr('r', d => scaleArea(+d.casos));

            if( names_knn != null ) {

              for( let i = 0; i < names_knn.length; ++i ) {

                  let pos_a = knn_cities[names_knn[i].name.replace(/[^\x00-\x7F]/g, "")].centroid_xy;
                  let pos_b = knn_cities[influenced_city.name.replace(/[^\x00-\x7F]/g, "")].centroid_xy;


                  g_knn.append('line')
                    .attr('x1', pos_a[0])
                    .attr('x2', pos_b[0])
                    .attr('y1', pos_a[1])
                    .attr('y2', pos_b[1])
                    .style('fill', 'none')
                    .style('stroke', '#b5b5b5')
                    .style('stroke-width', 2);

                  g_knn.append('circle')
                    .attr('cx', pos_a[0])
                    .attr('cy', pos_a[1])
                    .attr('r', 3)
                    .style('fill', '#b5b5b5')
                    .style('stroke', '#6e6e6e')

                  g_knn.append('circle')
                    .attr('cx', pos_b[0])
                    .attr('cy', pos_b[1])
                    .attr('r', 5)
                    .style('fill', "#6e6e6e")
                    .style('stroke', '#000000');
              }


            }
            
            
                
            if( backup != null ) {
                casosByCity = backup;
            }
        }

        function hasIntersection(citiesA, citiesB) {
          let cities = new Set();

          for( let i = 0; i < citiesA.length; ++i )
            cities.add(citiesA[i]);

          for( let i = 0; i < citiesB.length; ++i )
            cities.add(citiesB[i]);

          return cities.length < citiesA.length+citiesB.length;
        }

        function drawBaseMapHull(container, countries, projection, geoJson, subset, update) {
            let backup = null;

            if( subset != null ) {
                backup = casosByCity;
                casosByCity = subset;
            } else {

                backup = casosByCity;

                // casosByCity = backup.filter(d => d.date.getTime() == lastDate.getTime());
                casosByCity = backup.filter(d => d.date.getTime() == casosByCity[0].date.getTime())
            }

            current = casosByCity;
            let max_casos = d3.max(casosByCity, d => d.casos);


            let path = d3.geoPath()
                .projection(projection);

            if( !update ) {
                container.selectAll('path')
                    .data(countries)
                    .enter().append('path')
                    .attr('d', d => { return path(d); })
                    .on('click', d => {

                      // if( showingTooltip ) {
                      //   tooltip.transition()
                      //       .duration(500)
                      //       .style('opacity', 0);
                      // } else {
                          let value = 0;
    
                          let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");
    
                          for (var i = 0; i < current.length; i++) {
                              let cityName = current[i]['cidade'].replace(/[^\x00-\x7F]/g, "");
                              if( cityName.trim() == name.trim() ) {
                                  value = current[i]['casos'];
                                  break;
                              }
                          }
                          tooltip.html("<p>"+d.properties.name+"</p>"+
                                      "<p>"+value+" caso(s) confirmados.</p>")
                              .style('left', (d3.event.pageX)+'px')
                              .style('top', (d3.event.pageY - 28)+'px');

                          let s = document.getElementById('tooltip').style;
                          s.opacity = 1;
                          function fade() {
                            (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                          }
                          fade();
                      // }
                      // showingTooltip = !showingTooltip;
                    })
                    // .on('mouseout', d => {
                        
                    // });


            } 
            
            let filtered_current = current.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") in knn_cities);

            container.selectAll('path')
              .transition()
              .duration(update ? 1000 : 0)
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill', d => {

                    let value = 0;
                    if( value == 0 )
                        return '#fff';

                    // return d3.interpolateReds(value/max_casos);
                });

            let scaleArea = d3.scaleLog()
                .domain([1, d3.max(backup, d => +d.casos)])
                .range([5, 20]);

            let scaleArea2 = d3.scaleLog()
                .domain([1, Math.pow(Math.round(scaleArea.invert(25/2)), 2)])
                .range([5, 20])

            let scaleLegend = Math.pow(Math.round(scaleArea.invert(25/2)), 2) > d3.max(backup, d => +d.casos) ?
                              scaleArea : scaleArea2;


            let g = null, g_knn = null;
            if( !update ) {
                g = container.append('g')
                    .attr('class', 'real_cases');     

                g_knn = container.append('g')
                  .attr('class', 'knn_cases');

                let g_legend = container.append('g')
                    .attr('transform', 'translate(0,20)');   

                let max = 4;
                let step = (d3.max(backup, d => +d.casos) - d3.min(backup, d => +d.casos))/max;


                let numbers = [...new Set(backup.map(d =>  +d.casos))].sort(function compare(a, b) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                });
              
                let numbers_legend = [1,  Math.round(scaleArea.invert((20+5)/2)), Math.pow(Math.round(scaleArea.invert(25/2)), 2)];

                g_legend.append('circle')
                    .attr('cx', d => 15)
                    .attr('cy', d => 50)
                    .attr('r', scaleLegend(numbers_legend[0]))
                    .style('fill', '#eb4034')
                    .style('fill-opacity', 0.2)
                    .style('stroke', '#eb4034')
                    .style('stroke-opacity', 0.8);  

                g_legend.append('text')
                        .attr('x', d => 15)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text('1');
                
                let r_before = scaleLegend(numbers_legend[0]);
                let x_before = 15;

                for( let  i = 1; i < numbers_legend.length; i++ ) {

                    let r = scaleLegend(numbers_legend[i]);

                    g_legend.append('circle')
                        .attr('cx', d => x_before + r_before + 20 + r)
                        .attr('cy', d => 50)
                        .attr('r', r)
                        .style('fill', '#eb4034')
                        .style('fill-opacity', 0.2)
                        .style('stroke', '#eb4034')
                        .style('stroke-opacity', 0.8);  

                    g_legend.append('text')
                        .attr('x', d => x_before + r_before + 20 + r)
                        .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 16)
                        .style('font-family', 'Helvetica')
                        .text(numbers_legend[i]);

                    r_before = r;
                    x_before = x_before + r_before + 20 + r;

                }
                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 20)
                  .style('font-size', 16)
                  .style('font-family', 'Helvetica')
                  .attr('text-anchor', 'start')
                  .text('CASOS CONFIRMADOS*');


                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 120)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('*Dimensionamento dos círculos:'); 

                g_legend.append('text')
                  .attr('x', d => 10)
                  .attr('y', d => 130)
                  .attr('text-anchor', 'start')
                  .style('font-size', 10)
                  .style('font-family', 'Helvetica')
                  .text('Escala logarítmica.');  


                let g_description = container.append('g')
                    .attr('transform', 'translate(10,650)');   

                addUnespDescription(g_description);

            } else {
                g = container.select('.real_cases');
                container.select('.knn_cases').selectAll("*").remove();
                g_knn = container.select('.knn_cases');
            }

            
            
            let circle = g.selectAll('circle')
                .data(filtered_current, d => d.cidade);

            circle.exit().remove();

            circle.enter().append('circle')
                .attr('cx', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[0])// 
                .attr('cy', d => knn_cities[d.cidade.replace(/[^\x00-\x7F]/g, "")].centroid_xy[1])//
                .on('click', d => {
                    tooltip.html("<p>"+d.cidade+"</p>"+
                                "<p>"+d.casos+" caso(s) confirmados.</p>")
                        .style('left', (d3.event.pageX)+'px')
                        .style('top', (d3.event.pageY - 28)+'px');

                    let s = document.getElementById('tooltip').style;
                    s.opacity = 1;
                    function fade() {
                      (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                    }
                    fade();
                 })
                .style('fill', '#eb4034')
                .style('fill-opacity', 0.2)
                .style('stroke', '#eb4034')
                .style('stroke-opacity', 0.8)
              .merge(circle)
              .transition()
              .duration(500)
                  .attr('r', d => scaleArea(+d.casos));

            let set_first = disjointSet();
            let set_second = disjointSet();

            let cities_first_level = [];
            let cities_second_level = [];

            for( let i = 0; i < filtered_current.length; ++i ) {
              let name_current = filtered_current[i].cidade.replace(/[^\x00-\x7F]/g, "");
              let start = knn_cities[name_current].centroid_xy;
              

              let values = getKNN(name_current);

              g_knn.append('circle')
                .attr('cx', start[0])
                .attr('cy', start[1])
                .attr('r', 5)
                .style('fill', 'none')
                .style('stroke', '#000')
                .style('stroke-width', 1);


              let points = [];
              let points_level2 = [];

              let citiesA = [], coordsA = [];
              
              let citiesB = [], coordsB = [];
              for( let j = 0; j < values.length; ++j ) {
                let name_knn = values[j].replace(/[^\x00-\x7F]/g, "");
                let end = knn_cities[name_knn].centroid_xy;

                citiesA.push(name_current);
                coordsA.push(end);
                

                points.push(end);
                
                let second_level = getKNN(name_knn);
                for( let k = 0; k < kSecondLevel; ++k ) {
                  let name = second_level[k].replace(/[^\x00-\x7F]/g, "");
                  citiesB.push(name);
                  coordsB.push(knn_cities[name].centroid_xy);
                  points_level2.push(knn_cities[name].centroid_xy);
                }
                
              }

              let objA = {
                names: citiesA,
                coords: coordsA
              };
              cities_first_level.push(objA);
              set_first.add(objA);

              let objB = {
                  names: citiesB,
                  coords: coordsB
                };
                cities_second_level.push(objB);
                set_second.add(objB);
              



              // g_knn.append('path')
              //   .attr('class', 'hull')
              //   .datum(d3.polygonHull(points_level2))
              //     .attr('d', d => "M" + d.join("L") + "Z")
              //     .style('fill','#4287f5')
              //     .style('fill-opacity', 0.2)
              //     .style('stroke','#4287f5')
              //     .style('stroke-width','0.4px')
              //     .style('stroke-linejoin', 'round');

              // g_knn.append('path')
              //   .attr('class', 'hull')
              //   .datum(d3.polygonHull(points))
              //     .attr('d', d => "M" + d.join("L") + "Z")
              //     .style('fill','#9205eb')
              //     .style('fill-opacity', 0.2)
              //     .style('stroke','#9205eb')
              //     .style('stroke-width','0.4px')
              //     .style('stroke-linejoin', 'round');
            }

            let geometryFactory = new jsts.geom.GeometryFactory();

            console.log('cities_first_level');
            for( let i = 0; i < cities_first_level.length; ++i ) {
              for( let j = 0; j < cities_first_level.length; ++j ) {
                if( i == j ) 
                  continue;
                // let inter = greinerHormann.intersection(cities_first_level[i].coords, cities_first_level[j].coords);
                // if( inter ) {
                //     // console.log('1. union names');
                //     // console.log(cities_first_level[i].names);
                //     // console.log(cities_first_level[j].names);
                //     set_first.union(cities_first_level[i], cities_first_level[j]);
                // }

                let coordsA = d3.polygonHull(cities_first_level[i].coords);
                let coordinatesA = [];
                for( let k = 0; k < coordsA.length; ++k ){
                  let p = coordsA[k];
                  coordinatesA.push(new jsts.geom.Coordinate(p[0], p[1]));
                }
                coordinatesA.push(coordinatesA[0]);
                var shellA = geometryFactory.createLinearRing(coordinatesA)
                var polyA = geometryFactory.createPolygon(shellA);

                let coordsB = d3.polygonHull(cities_first_level[j].coords);
                let coordinatesB = [];
                for( let k = 0; k < coordsB.length; ++k ){
                  let p = coordsB[k];
                  coordinatesB.push(new jsts.geom.Coordinate(p[0], p[1]));
                }
                coordinatesB.push(coordinatesB[0]);
                var shellB = geometryFactory.createLinearRing(coordinatesB);
                var polyB = geometryFactory.createPolygon(shellB);


                if( polyA.intersects(polyB) ) {
                  set_first.union(cities_first_level[i], cities_first_level[j]);
                }

              }
            }

            console.log('cities_second_level');
            for( let i = 0; i < cities_second_level.length; ++i ) {
              for( let j = 0; j < cities_second_level.length; ++j ) {
                if( i == j ) 
                  continue;
                // let inter = greinerHormann.intersection(cities_second_level[i].coords, cities_second_level[j].coords);
                console.log('d3.polygonHull');
                let coordsA = d3.polygonHull(cities_second_level[i].coords);
                let coordinatesA = [];
                for( let k = 0; k < coordsA.length; ++k ){
                  let p = coordsA[k];
                  coordinatesA.push(new jsts.geom.Coordinate(p[0], p[1]));
                }
                coordinatesA.push(coordinatesA[0]);
                var shellA = geometryFactory.createLinearRing(coordinatesA)
                var polyA = geometryFactory.createPolygon(shellA);

                let coordsB = d3.polygonHull(cities_second_level[j].coords);
                let coordinatesB = [];
                for( let k = 0; k < coordsB.length; ++k ){
                  let p = coordsB[k];
                  coordinatesB.push(new jsts.geom.Coordinate(p[0], p[1]));
                }
                coordinatesB.push(coordinatesB[0]);
                var shellB = geometryFactory.createLinearRing(coordinatesB);
                var polyB = geometryFactory.createPolygon(shellB);


                if( polyA.intersects(polyB) ) {
                  set_second.union(cities_second_level[i], cities_second_level[j]);
                }


                // extent.forEach(function(vertex) {
                //  var p = projection.invert(vertex)
                //  coordinates.push(new jsts.geom.Coordinate(p[0], p[1]))
                // })

                // // close polygon
                // coordinates.push(coordinates[0])

                // var shell = geometryFactory.createLinearRing(coordinates)
                // var searchPolygon = geometryFactory.createPolygon(shell)

                // rTree.query(searchPolygon.getEnvelopeInternal()).forEach(function(d) {
                //   d.scanned = true
                //   if(d.polygon.intersects(searchPolygon)) d.selected = true
                // })


                // if( inter ) {
                //     // console.log('2. union names');
                //     // console.log(cities_second_level[i].names);
                //     // console.log(cities_second_level[j].names);
                //     set_second.union(cities_second_level[i], cities_second_level[j]);
                // }

              }
            }

            // console.log('set_first.extract()');
             let first = set_first.extract();
            // console.log(first);
            // console.log('set_second.extract()');

            let second = set_second.extract(); 
            // console.log(second);

           
            for( let i = 0; i < first.length; ++i ) {
              let points = [];
              for( let j = 0; j < first[i].length; ++j ) {
                for( let k = 0; k < first[i][j].coords.length; ++k )
                  points.push(first[i][j].coords[k]);
              }


              g_knn.append('path')
                .attr('class', 'hull')
                .datum(d3.polygonHull(points))
                  .attr('d', d => "M" + d.join("L") + "Z")
                  .style('fill','#4287f5')
                  .style('fill-opacity', 0.2)
                  .style('stroke','#4287f5')
                  .style('stroke-width','0.4px');


            }

           for( let i = 0; i < second.length; ++i ) {
            let points = [];
            console.log(second);
            for( let j = 0; j < second[i].length; ++j ) {
              for( let k = 0; k < second[i][j].coords.length; ++k )
                points.push(second[i][j].coords[k]);
            }

            g_knn.append('path')
              .attr('class', 'hull')
              .datum(d3.polygonHull(points))
                .attr('d', d => "M" + d.join("L") + "Z")
                .style('fill','#9205eb')
                .style('fill-opacity', 0.2)
                .style('stroke','#9205eb')
                .style('stroke-width','0.4px');


            }



            




              
            
                
            if( backup != null ) {
                casosByCity = backup;
            }
        }


        function filterByCityName(cityName) {
          return casosByCity.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") == cityName.replace(/[^\x00-\x7F]/g, ""));
        }

        function drawMortalityRate() {

            let geoJson = store.geoJSON;
            let evolucao = store.evolucao;

            let sumCasos = 0;
            let sumObitos = 0;

            for (var i = 0; i < evolucao.length; i++) {
                evolucao[i].evolucao = +evolucao[i].evolucao;
                evolucao[i].casos_dia = +evolucao[i].casos_dia;
                evolucao[i].obitos = +evolucao[i].obitos;

                sumObitos += evolucao[i].obitos;

                evolucao[i].mortalityRate = (sumObitos/evolucao[i].evolucao); 

                let date_string = evolucao[i].data.split('/');
                let day = +date_string[0];

                let month = map_month[date_string[1]];

                let date = new Date(2020, month-1, day);

                evolucao[i].date = date;
            }

            firstDayAnalysis = evolucao[0].date;
            lastDayAnalysis = evolucao[evolucao.length-1].date;

            var margin = {
              top: 100,
              right: 80,
              bottom: 30,
              left: 60
            },
            twidth = 900 - margin.left - margin.right,
            theight = 500 - margin.top - margin.bottom;


            // let legends = d3.select("#statisticalCharts")
            //       .attr("width", twidth + margin.left + margin.right)
            //   .attr("height", theight + margin.top + margin.bottom)
            //   .append("g")
            //   .attr("transform", "translate(" + margin.left + "," + (margin.top - 30) + ")");


            let legends = d3.select("#taxaMortalidade")
                .attr("width", '100%')
                .attr("height", '100%')
                .attr('viewBox','0 0 '+Math.min(width,height) +' '+500 )
                .attr('preserveAspectRatio','xMinYMin')
              .append("g")
                .attr("transform",  "translate(" + margin.left + "," + (margin.top - 30) + ")");

            g_evolucao = legends.append('g')
                .attr('transform', 'translate(0,0)');


            let height_graph = 300;
            let width_graph = 650;

            let yScaleEvolucao = d3.scaleLinear()
                .domain([0, d3.max(evolucao, d => d.mortalityRate)])
                .range([height_graph, 0]);

            let yAxisEvolucao = d3.axisLeft()
                .scale(yScaleEvolucao)
                .ticks(5)
                .tickFormat(d3.format('.0%'));

            g_evolucao.append('g')
                .style('stroke-width', 1.5)
                .attr('transform', 'translate(0,'+yScaleEvolucao(d3.max(evolucao, d => d.mortalityRate))+')')
                .call(yAxisEvolucao)
              .selectAll('text')
                .attr('font-size', 16)
                .attr('font-family', 'Helvetica');


            let xScaleEvolucao = d3.scaleTime()
                .domain([evolucao[0].date, evolucao[evolucao.length-1].date])
                .range([0, width_graph]);

            let xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m-%Y"))            
                .scale(xScaleEvolucao);

            g_evolucao.append('g')
                .style('stroke-width', 1.5)
                .attr('transform', 'translate(0,'+yScaleEvolucao(0)+')')
                .call(xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 12)
                .attr('font-family', 'Helvetica')
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-65)");

            // draw new cases per day
            let line_mortality = d3.line()
                .x((d, i) => xScaleEvolucao(d.date) )
                .y(d => yScaleEvolucao(d.mortalityRate));

            let area_mortality = d3.area()
                .x((d, i) => xScaleEvolucao(d.date))
                .y0(height_graph)
                .y1((d, i) => yScaleEvolucao(d.mortalityRate));

            g_evolucao.append('path')
                .attr('class', 'line_mortality')
                .attr('d', line_mortality(evolucao))
                .attr('stroke', '#8a8a8a')
                .attr('stroke-width', 2)
                .attr('fill', 'none');

            g_evolucao.append('path')
                .attr('d', area_mortality(evolucao))
                .attr('stroke', 'none')
                .attr('fill', '#8a8a8a')
                .attr('fill-opacity', 0.3);




            // g_histogram.append('text')
            //     .attr('x', width_graph/2)
            //     .attr('y', -histogramScale(d3.max(count_days, d => Math.log(d.count)))-20)
            //     .attr('text-anchor', 'middle')
            //     .text('Número de tweets - Escala logarítmica');

            let mouseG = legends.append('g')
              //.attr('transform', 'translate(60, '+(height_graph+100)+')')
              .attr('class', 'mouse-over-effects');

            mouseG.append("path") // this is the black vertical line to follow mouse
              .attr("class", "mouse-line")
              .style("stroke", "#eee")
              .style("stroke-width", "1px")
              .style("opacity", "0");

            let lines = document.getElementsByClassName('line_mortality');

            let mousePerLine = mouseG.selectAll('.mouse-per-line')
              .data(evolucao.filter(d => d.date != null))
              .enter()
              .append("g")
              .attr("class", "mouse-per-line");


            mousePerLine.append("circle")
              .attr("r", 7)
              .style("stroke", function(d) {
                return '#eee';//color(d.name);
              })
              .style("fill", "none")
              .style('stroke', 'none')
              .style("stroke-width", "1px")
              .style("opacity", "0");

            mousePerLine.append("text")
              .attr("transform", "translate(10,3)");


            mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
              .attr('width', width) // can't catch mouse events on a g element
              .attr('height', height)
              .attr('fill', 'none')
              .attr('pointer-events', 'all')
              .on('mouseout', function() { // on mouse out hide line, circles and text
                d3.select(".mouse-line")
                  .style("opacity", "0");
                d3.selectAll(".mouse-per-line circle")
                  .style("opacity", "0");
                d3.selectAll(".mouse-per-line text")
                  .style("opacity", "0");
              })
              .on('mouseover', function() { // on mouse in show line, circles and text
                d3.select(".mouse-line")
                  .style("opacity", "1");
                d3.selectAll(".mouse-per-line circle")
                  .style("opacity", "1");
                d3.selectAll(".mouse-per-line text")
                  .style("opacity", "1");
              })
              .on('mousemove', function() { // mouse moving over canvas
                var mouse = d3.mouse(this);
                d3.select(".mouse-line")
                  .attr("d", function() {
                    var d = "M" + mouse[0] + "," + height;
                    d += " " + mouse[0] + "," + 0;
                    return d;
                  });

                d3.selectAll(".mouse-per-line")
                  .attr("transform", function(d, i) {
                    // var xDate = x.invert(mouse[0]),
                    //     bisect = d3.bisector(function(d) { return d.date; }).right;
                    //     idx = bisect(d.values, xDate);
                    if( i >= lines.length )
                      return;
                    var beginning = 0,
                        end = lines[i].getTotalLength(),
                        target = null;

                    while (true){
                      target = Math.floor((beginning + end) / 2);
                      pos = lines[i].getPointAtLength(target);
                      if ((target === end || target === beginning) && pos.x !== mouse[0]) {
                          break;
                      }
                      if (pos.x > mouse[0])      end = target;
                      else if (pos.x < mouse[0]) beginning = target;
                      else break; //position found
                    }
                    
                   let value = yScaleEvolucao.invert(pos.y);
                    if( value < 0)
                        value = 0;
                    
                    d3.select(this).select('text')
                      .attr('text-anchor', 'end')
                      .text((value*100).toFixed(2)+'%');
                    return "translate(" + (mouse[0] - 15) + "," + ((pos.y) ) +")";
                  });
              });
        }

        function drawMapAnalysis(accumulated_tweets, accumulated_cases, max_casos, max_tweets) {
          let config = getMapConfig("#mapAnalysis");
          let projection = getMapProjection(config, geoJson);

          drawAnalysis(config.container, geoJson.features, projection, geoJson, accumulated_tweets, accumulated_cases, max_casos, max_tweets);
        }

        function drawAnalysis(container, countries, projection, geoJson, accumulated_tweets, accumulated_cases, max_casos, max_tweets) {


              
            // let domain = d3.range(1,max_casos+1 + ((max_casos+1)/8), (max_casos+1)/8);

            // let domain = [1, 10, 20, 50, 100, 200, 500, 1000, max_casos];

            let domain = d3.range(1, max_casos);
            // console.log('domain');
            // console.log(domain);
            // alert(domain.length);

            let range = [
              d3.interpolateBlues(0.2),
              d3.interpolateBlues(0.3),
              d3.interpolateBlues(0.4),
              d3.interpolateBlues(0.5),
              d3.interpolateBlues(0.6),
              d3.interpolateBlues(0.7),
              d3.interpolateBlues(0.8),
              d3.interpolateBlues(0.9),
              d3.interpolateBlues(1),
            ];

            var color = d3.scaleQuantile()
                .domain(domain)
                .range(range);


            var colorChoropleth = d3.scaleQuantile()
                .domain(d3.range(2,10))
                .range(range);


            let path = d3.geoPath()
                .projection(projection);

            let paths = container.selectAll('path')
              .data(countries, d => d.id);

            paths.exit().remove();

            container.selectAll('path').style('fill-opacity', 0);


            let scale = d3.scaleLinear()
              .domain([1, max_tweets])
              .range([0.2, 1]);


            paths.enter().append('path')
                .attr('d', d => { return path(d); })
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill-opacity', 0)           
                    .style('fill', (d, j) => {



                        let value = 0;

                        for( let i = 0; i < accumulated_tweets.length; i++) {
                            let city = accumulated_tweets[i].cidade.split("-")[0].trim().replace(/[^\x00-\x7F]/g, "");


                            if( city == d.properties.name.trim().replace(/[^\x00-\x7F]/g, "") ) {
                                value = accumulated_tweets[i].count;
                                break;
                            }
                        }

                        return value == 0 ? '#fff' : color(value);
                    })
                    .style('fill-opacity', 1);



            for( let i = 0; i < accumulated_cases.length; ++i ) {
              accumulated_cases[i].casos = +accumulated_cases[i].casos;
              let city = accumulated_cases[i].cidade.replace(/[^\x00-\x7F]/g, "");

              for( let j = 0; j < countries.length; ++j ) {
                if( city == countries[j].properties.name.replace(/[^\x00-\x7F]/g, "")  ) {
                  accumulated_cases[i].long = +d3.geoCentroid(countries[j])[0];
                  accumulated_cases[i].lat = +d3.geoCentroid(countries[j])[1];
                
                  break;
                }
              }
            }


            let scaleArea = d3.scaleLog()
              .domain([1, max_casos])
              .range([2, 20]);

            container.select('.real_cases').selectAll("*").remove();
            
            let g = container.append('g')
                   .attr('class', 'real_cases');


            let circle = g.selectAll('circle')
                .data(accumulated_cases, d => d.cidade)
                .enter().append('circle')
                  .attr('cx', d => projection([+d.long, +d.lat])[0])
                  .attr('cy', d => projection([+d.long, +d.lat])[1])
                  .style('fill', 'none')
                  // .style('fill', '#eb4034')
                  // .style('fill-opacity', 0.2)
                  .style('stroke', '#eb4034')
                  .style('stroke-opacity', 1)
                  .style('stroke-width', 2)
                  .attr('r', d => { 
                    return scaleArea(+d.casos);
                  });


            if( currentDate == 0 ) {

              let scaleArea2 = d3.scaleLog()
                  .domain([1, Math.pow(Math.round(scaleArea.invert(22/2)), 2)])
                  .range([2, 20])

              let scaleLegend = Math.pow(Math.round(scaleArea.invert(22/2)), 2) > max_casos ?
                                scaleArea : scaleArea2;

              container.select('.legend').selectAll("*").remove();

              let g_legend = container.append('g')
                  .attr('class', 'legend')
                  .attr('transform', 'translate(0,20)');   

              let max = 4;
              let step = (max_casos - 1)/max;
            
              let numbers_legend = [1,  Math.round(scaleArea.invert((20+2)/2)), Math.pow(Math.round(scaleArea.invert(22/2)), 2)];


              let begin_y = 40;
              let begin_x = 650;

              g_legend.append('circle')
                  .attr('cx', d => begin_x)
                  .attr('cy', d => begin_y)
                  .attr('r', scaleLegend(numbers_legend[0]))
                  // .style('fill', '#eb4034')
                  // .style('fill-opacity', 0.2)
                  .style('fill', 'none')
                  .style('stroke', '#eb4034')
                  .style('stroke-opacity', 0.8)
                  .style('stroke-width', 2);  

              g_legend.append('text')
                      .attr('x', d => begin_x)
                      .attr('y', d => begin_y + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                      .attr('text-anchor', 'middle')
                      .style('font-size', 16)
                      .style('font-family', 'Helvetica')
                      .text('1');
              
              let r_before = scaleLegend(numbers_legend[0]);
              let x_before = begin_x;

              for( let  i = 1; i < numbers_legend.length; i++ ) {

                  let r = scaleLegend(numbers_legend[i]);

                  g_legend.append('circle')
                      .attr('cx', d => x_before + r_before + 20 + r)
                      .attr('cy', d => begin_y)
                      .attr('r', r)
                      // .style('fill', '#eb4034')
                      // .style('fill-opacity', 0.2)
                      .style('fill', 'none')
                      .style('stroke', '#eb4034')
                      .style('stroke-opacity', 1)
                      .style('stroke-width', 2);  

                  g_legend.append('text')
                      .attr('x', d => x_before + r_before + 20 + r)
                      .attr('y', d => begin_y + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                      .attr('text-anchor', 'middle')
                      .style('font-size', 20)
                      .style('font-family', 'Georgia, serif')
                      .text(numbers_legend[i]);

                  r_before = r;
                  x_before = x_before + r_before + 20 + r;

              }
              g_legend.append('text')
                .attr('x', d => begin_x-10)
                .attr('y', d => begin_y-30)
                .style('font-size', 20)
                .style('font-family', 'Georgia, serif')
                .attr('text-anchor', 'start')
                .text('Confirmed cases');


              // g_legend.append('text')
              //   .attr('x', d => 10)
              //   .attr('y', d => 120)
              //   .attr('text-anchor', 'start')
              //   .style('font-size', 10)
              //   .style('font-family', 'Helvetica')
              //   .text('*Dimensionamento dos círculos:'); 

              // g_legend.append('text')
              //   .attr('x', d => 10)
              //   .attr('y', d => 130)
              //   .attr('text-anchor', 'start')
              //   .style('font-size', 10)
              //   .style('font-family', 'Helvetica')
              //   .text('Escala logarítmica.');  

              var x = d3.scaleLinear()
                  .domain([2, 10])
                  .rangeRound([20, 20+350]);

              container.select('.key').selectAll("*").remove();

              var g_choropleth = container.append("g")
                  .attr("class", "key")
                  .attr("transform", "translate(0,"+40+")");

              let rect_width = 350/8;

              g_choropleth.selectAll("rect")
                .data(colorChoropleth.range().map(function(d) {
                    d = colorChoropleth.invertExtent(d);
                    if (d[0] == null) d[0] = x.domain()[0];
                    if (d[1] == null) d[1] = x.domain()[1];
                    return d;
                  }))
                .enter().append("rect")
                  .attr("height", 15)
                  .attr("x", function(d, i) { return i*rect_width - rect_width/2; })//return x(d[0]); })
                  .attr("width", function(d,i) { return  rect_width; })//x(d[1]) - x(d[0]); })
                  .attr("fill", function(d, i) { return i == 0 ? '#fff' : colorChoropleth(d[0]); });

              g_choropleth.append("text")
                  .attr("class", "caption")
                  .attr("x", x.range()[0]+28)
                  .attr("y", -10)
                  .attr("fill", "#000")
                  .style('font-size', 20)
                  .style('font-family', 'Georgia, serif')
                  .attr("text-anchor", "start")
                  .text("Number of tweets");

              g_choropleth.call(d3.axisBottom(x)
                  .tickSize(17)
                  .tickFormat(function(x, i) { return Math.floor(color.quantiles()[x-2]); })
                  .tickValues(colorChoropleth.domain()))
                  .style('font-size', 15)
                      .style('font-family', 'Georgia, serif')
                .select(".domain")
                  .remove();

            }
        }

        function drawStatisticalChartsTwitter(tweets) {

          let max_days = [...new Set(tweets.map(d => d.date.split(" ")[0]))].length;

          let count_days = [];
          for (var i = 0; i <= max_days; i++) {
              count_days.push({count: 0, date: null});
          }

          let lastDay = new Date(2020, 1, 27);
          let firstDay = new Date(2020, 1, 27); // begin of the analysis
          let one_day = 1000*60*60*24;

          for (var i = 0; i < tweets.length; i++) {
              let date = tweets[i].date_object;

              let difference_ms = date - firstDay;
              let diasfrom = Math.round(difference_ms/one_day);
              tweets[i].diasfrom = diasfrom;

              count_days[diasfrom].count += 1;
              count_days[diasfrom].date = date;

              if( count_days[diasfrom].date > lastDay ) 
                  lastDay = count_days[diasfrom].date;
          }

          var margin = {
            top: 20,
            right: 80,
            bottom: 30,
            left: 50
          },
          twidth = 900 - margin.left - margin.right,
          theight = 500 - margin.top - margin.bottom;


          // let legends = d3.select("#statisticalChartsTwitter")
          //         .attr("width", '100%')// twidth + margin.left + margin.right)
          //     .attr("height", theight + margin.top + margin.bottom)
          //     .append("g")
          //     .attr("transform", "translate(" + margin.left + "," + (margin.top - 30) + ")");
          let legends =    d3.select("#statisticalChartsTwitter")
              .attr("width", '100%')
            .attr("height", '80%')
            .attr('viewBox','0 0 '+Math.min(width,height) +' '+500 )
            .attr('preserveAspectRatio','xMinYMin')
            .append("g")
            .attr("transform",  "translate(" + margin.left + "," + (margin.top - 30) + ")");

          // console.log(d3.select("#statisticalChartsTwitter").style('width').split('.')[])
          // console.log(d3.select("#statisticalChartsTwitter").attr('width'))
          let width_graph = 650;
          let height_graph = 300;

          let g_histogram = legends.append('g')
              .attr('transform', 'translate(0, '+(height_graph+100)+')');



          let histogramScale = d3.scaleLinear()
                                  .domain([0, d3.max(count_days, d => (d.count))])
                                  .range([0, height_graph]);



          let axisLeftScale = d3.scaleLinear()
              .domain([0, d3.max(count_days, d => (d.count))]).range([height_graph, 0]);

          let x_axis = d3.axisLeft()
              .scale(axisLeftScale)
              .ticks(5);

          g_histogram.append('g')
              .style('stroke-width', 1.5)
              .attr('class', 'tick_values')
              .attr('transform', 'translate(0,-'+histogramScale(d3.max(count_days, d => (d.count)))+')')
              .call(x_axis)
            .selectAll('text')
              .attr('font-size', 16)
              .attr('font-family', 'Helvetica');


          let xScale = d3.scaleTime()
              .domain([firstDayAnalysis, lastDayAnalysis])
              .range([0, width_graph]);

          let xAxis = d3.axisBottom()
              .tickFormat(d3.timeFormat("%d-%m-%Y"))
              .scale(xScale);

          g_histogram.append('g')
              .style('stroke-width', 1.5)
              .attr('class', 'tick_values')
              .attr('transform', 'translate(0,0)')
              .call(xAxis)
            .selectAll("text")
              .attr('font-size', 12)
              .attr('font-family', 'Helvetica')
              .style("text-anchor", "end")
              .attr("dx", "-.8em")
              .attr("dy", ".15em")
              .attr("transform", "rotate(-65)");


          let line_twitter = d3.line()
              .x((d, i) => xScale(d.date))
              .y(d => -histogramScale((d.count)))
              .curve(d3.curveCardinal.tension(0.5));

          let area_twitter = d3.area()
              .x((d, i) => xScale(d.date))
              .y0(-histogramScale(0))
              .y1(d => -histogramScale((d.count)))
              .curve(d3.curveCardinal.tension(0.5));

          g_histogram.append('path')
            .attr('class', 'line')
              .attr('d', line_twitter(count_days.filter(d => d.date != null)))
              .attr('stroke', '#70b0ff')
              .attr('stroke-width', 2)
              .attr('fill', 'none');

          g_histogram.append('path')
              .attr('d', area_twitter(count_days.filter(d => d.date != null)))
              .attr('stroke', 'none')
              .attr('fill', '#70b0ff')
              .attr('fill-opacity', 0.3);

          g_histogram.append('circle')
            .attr('cx', 30)
            .attr('cy', -histogramScale(d3.max(count_days, d => (d.count)))-25)
            .attr('r', 5)
            .style('fill', '#70b0ff')
            .style('stroke', 'none');

          g_histogram.append('text')
            .attr('x', 40)
            .attr('y', -histogramScale(d3.max(count_days, d => (d.count)))-20)
            .attr('font-size', 16)
            .attr('font-family', 'Helvetica')
            .text('Número de tweets');

          // g_histogram.append('text')
          //     .attr('x', width_graph/2)
          //     .attr('y', -histogramScale(d3.max(count_days, d => Math.log(d.count)))-20)
          //     .attr('text-anchor', 'middle')
          //     .text('Número de tweets - Escala logarítmica');

          let mouseG = legends.append('g')
            //.attr('transform', 'translate(60, '+(height_graph+100)+')')
            .attr('class', 'mouse-over-effects');

          mouseG.append("path") // this is the black vertical line to follow mouse
          .attr("class", "mouse-line")
          .style("stroke", "#eee")
          .style("stroke-width", "1px")
          .style("opacity", "0");

          let lines = document.getElementsByClassName('line');

          let mousePerLine = mouseG.selectAll('.mouse-per-line')
            .data(count_days.filter(d => d.date != null))
            .enter()
            .append("g")
            .attr("class", "mouse-per-line");


          mousePerLine.append("circle")
            .attr("r", 7)
            .style("stroke", function(d) {
              return '#eee';//color(d.name);
            })
            .style("fill", "none")
            .style('stroke', 'none')
            .style("stroke-width", "1px")
            .style("opacity", "0");

          mousePerLine.append("text")
            .attr("transform", "translate(10,3)");


          mouseG.append('svg:rect') // append a rect to catch mouse movements on canvas
            .attr('width', width) // can't catch mouse events on a g element
            .attr('height', height)
            .attr('fill', 'none')
            .attr('pointer-events', 'all')
            .on('mouseout', function() { // on mouse out hide line, circles and text
              d3.select(".mouse-line")
                .style("opacity", "0");
              d3.selectAll(".mouse-per-line circle")
                .style("opacity", "0");
              d3.selectAll(".mouse-per-line text")
                .style("opacity", "0");
            })
            .on('mouseover', function() { // on mouse in show line, circles and text
              d3.select(".mouse-line")
                .style("opacity", "1");
              d3.selectAll(".mouse-per-line circle")
                .style("opacity", "1");
              d3.selectAll(".mouse-per-line text")
                .style("opacity", "1");
            })
            .on('mousemove', function() { // mouse moving over canvas
              var mouse = d3.mouse(this);
              d3.select(".mouse-line")
                .attr("d", function() {
                  var d = "M" + mouse[0] + "," + height;
                  d += " " + mouse[0] + "," + 0;
                  return d;
                });

              d3.selectAll(".mouse-per-line")
                .attr("transform", function(d, i) {
                  // var xDate = x.invert(mouse[0]),
                  //     bisect = d3.bisector(function(d) { return d.date; }).right;
                  //     idx = bisect(d.values, xDate);
                  if( i >= lines.length )
                    return;
                  var beginning = 0,
                      end = lines[i].getTotalLength(),
                      target = null;

                  while (true){
                    target = Math.floor((beginning + end) / 2);
                    pos = lines[i].getPointAtLength(target);
                    if ((target === end || target === beginning) && pos.x !== mouse[0]) {
                        break;
                    }
                    if (pos.x > mouse[0])      end = target;
                    else if (pos.x < mouse[0]) beginning = target;
                    else break; //position found
                  }
                  
                  d3.select(this).select('text')
                    .attr('text-anchor', 'end')
                    .text(-Math.floor(histogramScale.invert(pos.y).toFixed(2)));
                  return "translate(" + (mouse[0] - 15) + "," + ((pos.y) +(height_graph+100)) +")";
                });
            });
        }

        function drawStatisticalChartsTwitterCity(tweets, cases) {
          let max_days = d3.max(tweets, d => d.diasfrom)+1;//[...new Set(tweets.map(d => d.date.split(" ")[0]))].length+1;

          let count_days = [];
          for (var i = 0; i <= max_days; i++) {
              count_days.push({count: 0, date: null});
          }

          for( let i = 0; i < cases.length; ++i ) {
            cases[i].casos = +cases[i].casos;
          }



          let cases_evolution = [cases[0]];
          let cases_current = cases[0].casos;
          for( let i = 1; i < cases.length; ++i ) {
            cases[i].casos = +cases[i].casos;
            if( cases[i].casos-cases_current > 0 ) {
              
              cases_evolution.push(cases[i]);
              cases_evolution[cases_evolution.length-1].casos = cases[i].casos-cases_current;
              cases_current = cases[i].casos;
            }
          }


          let lastDay = new Date(2020, 1, 27);
          let firstDay = new Date(2020, 1, 27); // begin of the analysis
          let one_day = 1000*60*60*24;

          for (var i = 0; i < tweets.length; i++) {
              let date = tweets[i].date_object;

              let difference_ms = date - firstDay;
              let diasfrom = Math.round(difference_ms/one_day);
              tweets[i].diasfrom = diasfrom;
              count_days[diasfrom].count += 1;
              count_days[diasfrom].date = date;

              if( count_days[diasfrom].date > lastDay ) 
                  lastDay = count_days[diasfrom].date;
          }

          var margin = {
            top: 20,
            right: 80,
            bottom: 30,
            left: 50
          },
          twidth = 900 - margin.left - margin.right,
          theight = 500 - margin.top - margin.bottom;


          // let legends = d3.select("#statisticalChartsTwitter")
          //         .attr("width", '100%')// twidth + margin.left + margin.right)
          //     .attr("height", theight + margin.top + margin.bottom)
          //     .append("g")
          //     .attr("transform", "translate(" + margin.left + "," + (margin.top - 30) + ")");
          let legends =    d3.select("#statisticalChartsTwitterCity")
              .attr("width", '100%')
            .attr("height", '80%')
            .attr('viewBox','0 0 '+Math.min(width,height) +' '+500 )
            .attr('preserveAspectRatio','xMinYMin')
            .append("g")
            .attr("transform",  "translate(" + margin.left + "," + (margin.top - 30) + ")");

          // console.log(d3.select("#statisticalChartsTwitter").style('width').split('.')[])
          // console.log(d3.select("#statisticalChartsTwitter").attr('width'))
          let width_graph = 650;
          let height_graph = 300;

          let g_histogram = legends.append('g')
              .attr('transform', 'translate(0, '+(height_graph+100)+')');


          let max_value = Math.max(d3.max(count_days, d => (d.count)), d3.max(cases_evolution, d => d.casos));


          let x = d3.scaleTime().range([0, width_graph]);
          let y = d3.scaleLinear().range([height_graph, 0]);


          function make_x_gridlines() {   
              return d3.axisBottom(x)
                  .ticks(5);
          }

          // gridlines in y axis function
          function make_y_gridlines() {   
              return d3.axisLeft(y)
                  .ticks(5);
          }

          x.domain([firstDayAnalysis, lastDayAnalysis]);
          y.domain([0, max_value]);


          g_histogram.append('g')
            .attr('class', 'grid')
            // .attr('transform', 'translate(0, '+height_graph+')')
            .call(make_x_gridlines()
                .tickSize(-height_graph)
                .tickFormat("")
            )

          g_histogram.append('g')
            .attr("class", "grid")
            .attr('transform', 'translate(0, -'+height_graph+')')
            .call(make_y_gridlines()
                .tickSize(-width_graph)
                .tickFormat("")
            )

          let histogramScale = d3.scaleLinear()
                                  .domain([0, max_value])
                                  .range([0, height_graph]);



          let axisLeftScale = d3.scaleLinear()
              .domain([0, max_value]).range([height_graph, 0]);

          let x_axis = d3.axisLeft()
              .scale(axisLeftScale)
              .ticks(5);



          let xScale = d3.scaleTime()
              .domain([firstDayAnalysis, lastDayAnalysis])
              .range([0, width_graph]);

          let xAxis = d3.axisBottom()
              .tickFormat(d3.timeFormat("%m-%d-%Y"))
              .scale(xScale);

          g_histogram.append('g')
              .style('stroke-width', 1.5)
              .attr('class', 'tick_values')
              .attr('transform', 'translate(0,-'+histogramScale(max_value)+')')
              .call(x_axis)
            .selectAll('text')
              .attr('font-size', 16)
              .attr('font-family', 'Helvetica');



          g_histogram.append('g')
              .style('stroke-width', 1.5)
              .attr('class', 'tick_values')
              .attr('transform', 'translate(0,0)')
              .call(xAxis)
            .selectAll("text")
              .attr('font-size', 16)
              .attr('font-family', 'Helvetica')
              .style("text-anchor", "end")
              .attr("dx", "-.8em")
              .attr("dy", ".15em")
              .attr("transform", "rotate(-65)");


          let line_twitter = d3.line()
              .x((d, i) => xScale(d.date))
              .y(d => -histogramScale((d.count)));

          let area_twitter = d3.area()
              .x((d, i) => xScale(d.date))
              .y0(-histogramScale(0))
              .y1(d => -histogramScale((d.count)));

          g_histogram.append('path')
            .attr('class', 'line')
              .attr('d', line_twitter(count_days.filter(d => d.date != null)))
              .attr('stroke', '#70b0ff')
              .attr('stroke-width', 2)
              .attr('fill', 'none');

          g_histogram.append('path')
              .attr('d', area_twitter(count_days.filter(d => d.date != null)))
              .attr('stroke', 'none')
              .attr('fill', '#70b0ff')
              .attr('fill-opacity', 0.3);


          g_histogram.selectAll('.dot-twitter')
              .data(count_days.filter(d => d.date != null))
            .enter().append('circle')
              .attr('class', 'dot-twitter')
              .attr('cx', d => xScale(d.date))
              .attr('cy', d => -histogramScale(d.count))
              .attr('r', 4)
              .style('fill', '#70b0ff');

          g_histogram.append('circle')
            .attr('cx', 30)
            .attr('cy', -histogramScale(max_value)+40)
            .attr('r', 5)
            .style('fill', '#70b0ff')
            .style('stroke', 'none');

          g_histogram.append('text')
            .attr('x', 40)
            .attr('y', -histogramScale(max_value)+45)
            .attr('font-size', 16)
            .attr('font-family', 'Helvetica')
            .text('Number of tweets');


          g_histogram.append('circle')
            .attr('cx', 30)
            .attr('cy', -histogramScale(max_value)+20)
            .attr('r', 5)
            .style('fill', '#f55a42')
            .style('stroke', 'none');

          g_histogram.append('text')
            .attr('x', 40)
            .attr('y', -histogramScale(max_value)+25)
            .attr('font-size', 16)
            .attr('font-family', 'Helvetica')
            .text('Confirmed cases');


          console.log('cases_evolution')
          console.log(cases_evolution);

          let scaleHeight = d3.scaleLinear()
            .domain([1, d3.max(cases_evolution, d => d.casos)])
            .range([10, height_graph]);

          let line_casos = d3.line()
              .x((d, i) => xScale(d.date))
              .y(d => -histogramScale(d.casos));

          g_histogram.append('path')
            .attr('class', 'line')
              .attr('d', line_casos(cases_evolution))
              .attr('stroke', '#f55a42')
              .attr('stroke-width', 2)
              .attr('fill', 'none');

          g_histogram.selectAll('.dot-confirmed')
              .data(cases_evolution)
            .enter().append('circle')
              .attr('class', 'dot-confirmed')
              .attr('cx', d => xScale(d.date))
              .attr('cy', d => -histogramScale(d.casos))
              .attr('r', 4)
              .style('fill', '#f55a42');
        }

        function getStd(values, mean) {
          let std = 0;

          for( let i = 0; i < values.length; ++i ) {
            std += Math.pow((values[i] - mean), 2);
          }

          return Math.sqrt(std/values.length);


        }

        function getMean(values) {
          let sum = 0.0;

          for( let i = 0; i < values.length; ++i )
            sum += values[i];

          return sum/values.length;
        }

        function getNewCases(values) {
          let new_cases = [+values[0].casos];

          for( let i = 1; i < values.length; ++i ) {
            new_cases.push((+values[i].casos) - (+values[i-1].casos));

            
          }

          return new_cases;
        }

        function getSlope(values, days) {
          let y2 = +values[values.length-1].casos;
          let y1 = 0;
          if( values.length == days )
              y1 = values[0].casos;
          else if( values.length > days )
              y1 = values[values.length-days].casos;

          return [(y2-y1) > 0 ? (y2-y1)/days : -1*((y2-y1)/days), +y1, +y2];
        }

        function formString(date) {
          return date.getDate()+"_"+date.getMonth()+"_"+date.getFullYear();
        }

        function getUnion(knn_cases) {

          let values_new_cases = {};
          let values_cases = {};
          let dates = new Set();

          for( let i = 0; i < knn_cases.length; ++i ) {
            for( let j = 0; j < knn_cases[i].acc.length; ++j ) {

              let key = formString(knn_cases[i].acc[j].date);
              dates.add(key);

              if( !(key in values_cases) ) {
                values_cases[key] = 0;
              }

              values_cases[key] += knn_cases[i].acc[j].value;
            }

            for( let j = 0; j < knn_cases[i].new_c.length; ++j ) {
              let key = formString(knn_cases[i].new_c[j].date);
              if( !(key in values_new_cases) ) {
                values_new_cases[key] = 0;
              }

              values_new_cases[key] += knn_cases[i].new_c[j].value;
            }

          }
          


          let acc = [];
          Object.keys(values_cases).forEach(function(key) {
            let splitted = key.split("_");

            acc.push({
              date: new Date(+splitted[2], +splitted[1], +splitted[0]),
              value: values_cases[key]
            });
          });
          
          let new_c = [];
          Object.keys(values_new_cases).forEach(function(key) {
            let splitted = key.split("_");

            new_c.push({
              date: new Date(+splitted[2], +splitted[1], +splitted[0]),
              value: values_new_cases[key]
            });
          });

          
          return [acc.sort((a, b) => new Date(a.date) - new Date(b.date)), new_c.sort((a, b) => new Date(a.date) - new Date(b.date))];
        }

        function addAnalysisCity(all_knn_cases, all_data, name) {
          let acc2 = null;
          let new_c2 = null;
          if( all_data.length > 0 ) {
            acc2 = [{date: all_data[0].date, value: +all_data[0].casos}];
            new_c2 = [{date: all_data[0].date, value: +all_data[0].casos}];

            for( let j = 1; j < all_data.length; ++j ) {
              acc2.push({date: all_data[j].date, value: +all_data[j].casos});
              new_c2.push({date: all_data[j].date, value: (+all_data[j].casos) - (+all_data[j-1].casos)});
            }  
          } 

          if( all_data.length > 0 ) {
            let casos = +(all_data[all_data.length-1].casos);

            let temp_new_cases = getNewCases(all_data);
            let mean = getMean(temp_new_cases);
            let std = getStd(temp_new_cases, mean);
            let spread = std/mean;
            let slope_data = getSlope(all_data, window_analysis);

            all_knn_cases.push({
                name: name,
                value: casos,
                evolution: all_data,
                new_cases: temp_new_cases,
                mean: mean,
                std: std,
                spread: spread,
                slope: slope_data[0],
                slope_y1: slope_data[1],
                slope_y2: slope_data[2],
                acc: acc2,
                new_c: new_c2
            });
          }

          return all_knn_cases;
        }


        function getCasesBefore(array, date) {
          for( let i = 0; i < array.length; ++i )
            if( array[i].date.getTime() === date.getTime() )
              return array[i].casos;


          return 0;


        }



        function addRiskMeasures(city, description, day, window_analysis) {
          let chart = risk_data[0];

          chart.select('.principal').selectAll("*").remove();
          chart.select('.slopeArea').selectAll("*").remove();
          chart.select('.aggregatedArea').selectAll('*').remove();
          

          let windowvis = chart.select('.windowvis');
          let temp = new Date();

          temp.setTime(day.getTime() - (24*60*60*1000)*window_analysis);
          windowvis.select('.window-rect')
            .transition()
            .attr('x', general_xScaleEvolucao(temp));

          let evolution_city = casosByCity.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") == city);

          let evolution_city_limited = casosByCity.filter(d => {
              if( d.date.getTime() > day.getTime() )
                return false;
              let time = day.getTime() - d.date.getTime();
              let days = time / (1000 * 3600 * 24);
              
              return days <= window_analysis && d.cidade.replace(/[^\x00-\x7F]/g, "") == city;
          });

          // if( evolution_city.length > 0 ) {


            let knn_cases = [], all_knn_cases = [];
            let cities = reversed_knn[city];
            for( let i = 0; i < cities.length; ++i ) {

              

              let temp = casosByCity.filter(d => {
                  if( d.date.getTime() > day.getTime() )
                    return false;
                  let time = day.getTime() - d.date.getTime();
                  let days = time / (1000 * 3600 * 24);
                  
                  return days <= window_analysis && d.cidade.replace(/[^\x00-\x7F]/g, "") == cities[i].replace(/[^\x00-\x7F]/g, "")

              });
              
              let all_data = casosByCity.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") == cities[i].replace(/[^\x00-\x7F]/g, ""));
              let max_cases = 0;
              if( all_data.length > 0 ) {

                max_cases = +all_data[all_data.length-1].casos;
              }


              let temp_all = casosByCity.filter(d => {
                if( d.date.getTime() > day.getTime() )
                    return false;
                let time = day.getTime() - d.date.getTime();
                let days = time / (1000 * 3600 * 24);


                return days <= window_analysis && d.cidade.replace(/[^\x00-\x7F]/g, "") == cities[i].replace(/[^\x00-\x7F]/g, "")
              });



              let acc = null;
              let new_c = null;
              if( temp.length > 0 ) {

                let dateBefore = new Date();
                dateBefore.setTime(day.getTime() - (24*60*60*1000)*(window_analysis+1));

                acc = [{date: temp[0].date, value: +temp[0].casos}];
                new_c = [{date: temp[0].date, value: +temp[0].casos - (+getCasesBefore(all_data, dateBefore))}];

                for( let j = 1; j < temp.length; ++j ) {
                  acc.push({date: temp[j].date, value: +temp[j].casos});
                  new_c.push({date: temp[j].date, value: (+temp[j].casos) - (+temp[j-1].casos)});
                }  
              } 


              

              if( temp.length > 0 ) {
                let casos = +(temp[temp.length-1].casos);

                let temp_new_cases = getNewCases(temp);
                let mean = getMean(temp_new_cases);
                let std = getStd(temp_new_cases, mean);
                let spread = std/mean;
                let slope_data = getSlope(temp, window_analysis);

                knn_cases.push({
                    name: cities[i],
                    value: casos,
                    evolution: temp,
                    new_cases: temp_new_cases,
                    mean: mean,
                    std: std,
                    spread: spread,
                    slope: slope_data[0],
                    slope_y1: slope_data[1],
                    slope_y2: slope_data[2],
                    acc: acc,
                    new_c: new_c,
                    max_cases: max_cases,
                });
              }

              let acc2 = null;
              let new_c2 = null;
              if( all_data.length > 0 ) {
                acc2 = [{date: all_data[0].date, value: +all_data[0].casos}];
                new_c2 = [{date: all_data[0].date, value: +all_data[0].casos}];

                for( let j = 1; j < all_data.length; ++j ) {
                  acc2.push({date: all_data[j].date, value: +all_data[j].casos});
                  new_c2.push({date: all_data[j].date, value: (+all_data[j].casos) - (+all_data[j-1].casos)});
                }  
              } 

              if( all_data.length > 0 ) {
                let casos = +(all_data[all_data.length-1].casos);

                let temp_new_cases = getNewCases(all_data);
                let mean = getMean(temp_new_cases);
                let std = getStd(temp_new_cases, mean);
                let spread = std/mean;
                let slope_data = getSlope(all_data, window_analysis);

                all_knn_cases.push({
                    name: cities[i],
                    value: casos,
                    evolution: all_data,
                    new_cases: temp_new_cases,
                    mean: mean,
                    std: std,
                    spread: spread,
                    slope: slope_data[0],
                    slope_y1: slope_data[1],
                    slope_y2: slope_data[2],
                    acc: acc2,
                    new_c: new_c2,
                    max_cases: max_cases,
                });
              }
              
            }

            console.log(description);
            console.log('knn_cases');
            console.log(knn_cases);

            if( knn_cases.length > 0 ) {

              // array of 

              let names_knn = [];

              for( let j = 0; j < knn_cases.length; ++j ) {
                names_knn.push({
                  name: knn_cases[j].name, 
                  casos: knn_cases[j].value
                });
              }

              let influenced_city = {
                name: description,
                casos: evolution_city_limited.length == 0 ? 0 : d3.max(evolution_city_limited, d => +d.casos)
              }

              drawBaseMapReal(configMapReal.container, geoJson.features, projectionMapReal, geoJson, null, true, names_knn, influenced_city);
            }

            


            all_knn_cases = addAnalysisCity(all_knn_cases, evolution_city, description);

            let union = getUnion(knn_cases);
            let all_union = getUnion(all_knn_cases);

            knn_cases = knn_cases.sort((a, b) => b.slope-a.slope);

            let acc_cases = [];
            let new_cases = [];

            if( evolution_city.length > 0 ) {
              acc_cases = [{date: evolution_city[0].date, value: +evolution_city[0].casos}];
              new_cases = [{date: evolution_city[0].date, value: +evolution_city[0].casos}];

              for( let i = 1; i < evolution_city.length; ++i ) {
                acc_cases.push({date: evolution_city[i].date, value: +evolution_city[i].casos});
                new_cases.push({date: evolution_city[i].date, value: (+evolution_city[i].casos) - (+evolution_city[i-1].casos)});
              }
            }

            let first_date = risk_data[1];
            let last_date = risk_data[2];
            let height_graph = 80;
            let width_graph = 150;
            let max_cases = acc_cases.length > 0 ? d3.max(acc_cases, d => d.value) : 0;

            let small_multiple = chart.select('.principal').append('g')
              .attr('class', 'small_multiple')
              .attr('transform', 'translate('+((25 + 30))+', '+(45)+')');

            

            let yScaleEvolucao = d3.scaleLinear()
                .domain([0, max_cases])
                .range([height_graph, 0]);

            let yAxisEvolucao = d3.axisLeft()
                .scale(yScaleEvolucao)
                .ticks(5);

            // small_multiple.append('g')
            //     .style('stroke-width', 0.8)
            //     .attr('transform', 'translate(0,'+yScaleEvolucao(max_cases)+')')
            //     .call(yAxisEvolucao)
            //   .selectAll('text')
            //     .attr('font-size', 8)
            //     .attr('font-family', 'Helvetica');

            let xScaleEvolucao = d3.scaleTime()
                .domain([first_date, last_date])
                .range([0, width_graph]);

            let xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m"))            
                .scale(xScaleEvolucao)
                .ticks(5);

            small_multiple.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,'+yScaleEvolucao(0)+')')
                .call(xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 8)
                .attr('font-family', 'Helvetica')
                // .style("text-anchor", "end")
                // .attr("dx", "-.8em")
                // .attr("dy", ".15em")
                // .attr("transform", "rotate(-20)");

            let line = d3.line()
                .x((d, i) => xScaleEvolucao(d.date))
                .y(d => yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            let area = d3.area()
                .x((d, i) => xScaleEvolucao(d.date))
                .y0(height_graph)
                .y1((d, i) => yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            small_multiple.append('path')
                .attr('class', 'line_real')
                .attr('d', line(acc_cases))
                .attr('stroke', '#ffab52')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            small_multiple.append('path')
                .attr('d', area(acc_cases))
                .attr('stroke', 'none')
                .attr('fill', '#ffab52')
                .attr('fill-opacity', 0.3);


            small_multiple.append('path')
                .attr('class', 'line_real')
                .attr('d', line(new_cases))
                .attr('stroke', '#000000')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            small_multiple.append('path')
                .attr('d', area(new_cases))
                .attr('stroke', 'none')
                .attr('fill', "#000000")
                .attr('fill-opacity', 0.3)

            small_multiple.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '12px')
              .style('text-anchor', 'start')
              .text(description);

            small_multiple.append('text')
              .attr('x', 0)
              .attr('y', 15)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '8px')
              .style('text-anchor', 'start')
              .attr('color', 'grey')
              .attr('font-weight', 'bold')
              .text('Casos: '+(acc_cases.length == 0 ? 0 : acc_cases[acc_cases.length-1].value));


            let thisSlope = [0, 0, 0];
            if( evolution_city_limited.length > 0 ) {
              thisSlope = getSlope(evolution_city_limited, window_analysis);
            }

            // let spSlope = getSlope(casosByCity.filter(d => {
            //       if( d.date.getTime() > day.getTime() )
            //         return false;
            //       let time = day.getTime() - d.date.getTime();
            //       let days = time / (1000 * 3600 * 24);
            //       return days <= window_analysis && d.cidade.replace(/[^\x00-\x7F]/g, "") == "São Paulo".replace(/[^\x00-\x7F]/g, "");

            //   }), window_analysis);


            // let innerRadiusScale = d3.scaleLinear()
            //   .domain([0, spSlope[0]])
            //   .range([8, 18]);

            let multiplier = 1.35;

            let outerRadius = Math.min(height_graph*multiplier, width_graph*multiplier) * .5 - 10,
                innerRadius = 18;//innerRadiusScale(thisSlope);// outerRadius * .6;
            
            let n = knn_cases.length;
            let data0 = [];
            let data1 = [];

            for( let i = 0; i < n; ++i ) {
              data0.push(1);
              data1.push(1);
            }

            let slopeScale = d3.scaleSqrt()
                .domain([0, Math.max(thisSlope[0], d3.max(knn_cases, d => d.slope))])
                .range([0, 1]);

            let color = d3.scaleOrdinal(d3.schemeCategory20);

            let arc = d3.arc();
            let pie = d3.pie().sort(null);


            let pie_multiple = small_multiple.append('g')
              .attr('transform', 'translate('+(width_graph+25 +40)+', -15)');

            let data_ready = arcs(data0, data1);


            pie_multiple.selectAll('.arc')
              .data(data_ready)
              .enter().append('g')
                .attr('class', 'arc')
                .attr('transform', 'translate('+width_graph*multiplier/2+','+height_graph*multiplier/2+')')
              .append('path')
                .attr('fill', (d, i) => d3.interpolateReds(slopeScale(knn_cases[i].slope)))
                .style('stroke', 'black')
                .attr('d', arc)
                .on('mouseover', (d, i) => {

                  let city_object = knn_cases[i];
                  chart.select('.slopeArea').selectAll("*").remove();
                  let slopeArea = chart.select('.slopeArea')
                    .append('g')
                      .attr('transform', 'translate(-5, -30)');

                  let slopeAreaWindow = slopeArea.append('g')
                    .attr('transform', 'translate(0, '+(height_graph*2 + 50)+')');

                  let acc = city_object.acc;
                  let new_c = city_object.new_c;
                  let new_acc = [];


                  for( let j = 0; j < acc.length; ++j ) {
                    new_acc.push({date: acc[j].date, value: acc[j].value});
                    new_acc[j].value = acc[j].value - (acc[0].value-new_c[0].value);
                  }

                  console.log('city_object');
                  console.log(city_object);

                   let neighbors_xScaleEvolucao = d3.scaleTime()
                      .domain([first_date, last_date])
                      .range([0, width_graph*2]);

                  let neighbors_xAxisEvolucao = d3.axisBottom()
                      .tickFormat(d3.timeFormat("%d-%m"))            
                      .scale(neighbors_xScaleEvolucao)
                      .ticks(5);


                  let neighbors_yScaleEvolucao = d3.scaleLinear()
                    .domain([0, d3.max(all_union[0], d => d.value)])
                    .range([height_graph*2, 0]);

                  let neighbors_line = d3.line()
                      .x((d, i) => neighbors_xScaleEvolucao(d.date))
                      .y(d => neighbors_yScaleEvolucao(d.value))
                      .curve(d3.curveCardinal.tension(0.5));

                  let neighbors_area = d3.area()
                      .x((d, i) => neighbors_xScaleEvolucao(d.date))
                      .y0(height_graph*2)
                      .y1((d, i) => neighbors_yScaleEvolucao(d.value))
                      .curve(d3.curveCardinal.tension(0.5));


                  slopeArea.append('g')
                      .style('stroke-width', 0.8)
                      .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                      .call(neighbors_xAxisEvolucao)
                    .selectAll("text")
                      .attr('font-size', 8)
                      .attr('font-family', 'Helvetica');

                  slopeAreaWindow.append('g')
                      .style('stroke-width', 0.8)
                      .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                      .call(neighbors_xAxisEvolucao)
                    .selectAll("text")
                      .attr('font-size', 8)
                      .attr('font-family', 'Helvetica');

                  

                  slopeArea.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(acc))
                      .attr('stroke', '#ff4f4f')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeArea.append('path')
                      .attr('d', neighbors_area(acc))
                      .attr('stroke', 'none')
                      .attr('fill', '#ff4f4f')
                      .attr('fill-opacity', 0.3);

                  slopeArea.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_c))
                      .attr('stroke', '#000000')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeArea.append('path')
                      .attr('d', neighbors_area(new_c))
                      .attr('stroke', 'none')
                      .attr('fill', "#000000")
                      .attr('fill-opacity', 0.3);

                  slopeAreaWindow.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_acc))
                      .attr('stroke', '#ff4f4f')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeAreaWindow.append('path')
                      .attr('d', neighbors_area(new_acc))
                      .attr('stroke', 'none')
                      .attr('fill', '#ff4f4f')
                      .attr('fill-opacity', 0.3);

                  slopeAreaWindow.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_c))
                      .attr('stroke', '#000000')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeAreaWindow.append('path')
                      .attr('d', neighbors_area(new_c))
                      .attr('stroke', 'none')
                      .attr('fill', "#000000")
                      .attr('fill-opacity', 0.3);

                  

                  slopeArea.append('text')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '12px')
                    .style('text-anchor', 'start')
                    .text(city_object.name);

                  slopeAreaWindow.append('text')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '12px')
                    .style('text-anchor', 'start')
                    .text(city_object.name);

                  slopeAreaWindow.append('text')
                    .attr('x', 0)
                    .attr('y', 15)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '8px')
                    .style('text-anchor', 'start')
                    .attr('color', 'grey')
                    .attr('font-weight', 'bold')
                    .text('Casos no período: '+(knn_cases[0].evolution >= window_analysis ? (city_object.slope_y2-city_object.slope_y1) : city_object.value));

                  slopeArea.append('text')
                    .attr('x', 0)
                    .attr('y', 15)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '8px')
                    .style('text-anchor', 'start')
                    .attr('color', 'grey')
                    .attr('font-weight', 'bold')
                    .text('Casos acumulados: '+city_object.value);

                });

            var labelArc = d3.arc()
              .innerRadius(innerRadius)         // This is the size of the donut hole
              .outerRadius(outerRadius)

            // Another arc that won't be drawn. Just for labels positioning
            var labelOuterArc = d3.arc()
              .innerRadius(innerRadius * 1.4)         // This is the size of the donut hole
              .outerRadius(outerRadius* 1.4)
            let radius = Math.min(height_graph*multiplier, width_graph*multiplier) /2;

            pie_multiple
              .selectAll('allPolylines')
              .data(data_ready)
              .enter().append('g')
                .attr('class', 'arc')
                .attr('transform', 'translate('+width_graph*multiplier/2+','+height_graph*multiplier/2+')')
              .append('polyline')
                .attr("stroke", "black")
                .style("fill", "none")
                .attr("stroke-width", 1)
                .attr('points', function(d) {
                  var posA = labelArc.centroid(d) // line insertion in the slice
                  var posB = labelOuterArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                  var posC = labelOuterArc.centroid(d); // Label position = almost the same as posB
                  var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                  posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
                  return [posA, posB, posC]
                });

            pie_multiple
              .append('g')
                .attr('class', 'arc')
                .attr('transform', 'translate('+width_graph*multiplier/2+','+height_graph*multiplier/2+')')
              .append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', innerRadius)
                .style('stroke', 'black')
                .style('fill', thisSlope[0] <= 0.1 ? 'white' : d3.interpolateReds(slopeScale(thisSlope[0])))
                .on('mouseover', (d, i) => {

                  
                  let city_object = {
                    name: description,
                    value: thisSlope[2],
                    slope_y1: thisSlope[1],
                    slope_y2: thisSlope[2],

                  };
                  
                  chart.select('.slopeArea').selectAll("*").remove();
                  let slopeArea = chart.select('.slopeArea')
                    .append('g')
                      .attr('transform', 'translate(-5, -30)');

                  let slopeAreaWindow = slopeArea.append('g')
                    .attr('transform', 'translate(0, '+(height_graph*2 + 50)+')');



                  let acc = null;
                  let new_c = null;
                  let new_acc = [];
                  if( evolution_city_limited.length > 0 ) {

                    let dateBefore = new Date();
                    dateBefore.setTime(day.getTime() - (24*60*60*1000)*(window_analysis+1));


                    acc = [{date: evolution_city_limited[0].date, value: +evolution_city_limited[0].casos}];
                    new_c = [{date: evolution_city_limited[0].date, value: +evolution_city_limited[0].casos - (+getCasesBefore(evolution_city, dateBefore))}];

                    for( let j = 1; j < evolution_city_limited.length; ++j ) {
                      acc.push({date: evolution_city_limited[j].date, value: +evolution_city_limited[j].casos});
                      new_c.push({date: evolution_city_limited[j].date, value: (+evolution_city_limited[j].casos) - (+evolution_city_limited[j-1].casos)});
                    }  


                    for( let j = 0; j < acc.length; ++j ) {
                      new_acc.push({date: acc[j].date, value: acc[j].value});
                      new_acc[j].value = acc[j].value - (acc[0].value-new_c[0].value);
                    }
                  } 


                  console.log('city_object');
                  console.log(city_object);

                   let neighbors_xScaleEvolucao = d3.scaleTime()
                      .domain([first_date, last_date])
                      .range([0, width_graph*2]);

                  let neighbors_xAxisEvolucao = d3.axisBottom()
                      .tickFormat(d3.timeFormat("%d-%m"))            
                      .scale(neighbors_xScaleEvolucao)
                      .ticks(5);

                  // console.log('MAX UNION: ', d3.max(all_union[0], d => d.value));
                  // console.log('MAX EVOLUTION: ',d3.max(evolution_city, d => +d.casos));


                  let neighbors_yScaleEvolucao = d3.scaleLinear()
                    .domain([0, d3.max(all_union[0], d => d.value)])
                    .range([height_graph*2, 0]);

                  let neighbors_line = d3.line()
                      .x((d, i) => neighbors_xScaleEvolucao(d.date))
                      .y(d => neighbors_yScaleEvolucao(d.value))
                      .curve(d3.curveCardinal.tension(0.5));

                  let neighbors_area = d3.area()
                      .x((d, i) => neighbors_xScaleEvolucao(d.date))
                      .y0(height_graph*2)
                      .y1((d, i) => neighbors_yScaleEvolucao(d.value))
                      .curve(d3.curveCardinal.tension(0.5));


                  slopeArea.append('g')
                      .style('stroke-width', 0.8)
                      .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                      .call(neighbors_xAxisEvolucao)
                    .selectAll("text")
                      .attr('font-size', 8)
                      .attr('font-family', 'Helvetica');

                  slopeAreaWindow.append('g')
                      .style('stroke-width', 0.8)
                      .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                      .call(neighbors_xAxisEvolucao)
                    .selectAll("text")
                      .attr('font-size', 8)
                      .attr('font-family', 'Helvetica');

                  

                  slopeArea.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(acc))
                      .attr('stroke', '#ff4f4f')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeArea.append('path')
                      .attr('d', neighbors_area(acc))
                      .attr('stroke', 'none')
                      .attr('fill', '#ff4f4f')
                      .attr('fill-opacity', 0.3);

                  slopeArea.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_c))
                      .attr('stroke', '#000000')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeArea.append('path')
                      .attr('d', neighbors_area(new_c))
                      .attr('stroke', 'none')
                      .attr('fill', "#000000")
                      .attr('fill-opacity', 0.3);


                  slopeAreaWindow.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_acc))
                      .attr('stroke', '#ff4f4f')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeAreaWindow.append('path')
                      .attr('d', neighbors_area(new_acc))
                      .attr('stroke', 'none')
                      .attr('fill', '#ff4f4f')
                      .attr('fill-opacity', 0.3);

                  slopeAreaWindow.append('path')
                      .attr('class', 'line_real')
                      .attr('d', neighbors_line(new_c))
                      .attr('stroke', '#000000')
                      .attr('stroke-width', 1.2)
                      .attr('fill', 'none');

                  slopeAreaWindow.append('path')
                      .attr('d', neighbors_area(new_c))
                      .attr('stroke', 'none')
                      .attr('fill', "#000000")
                      .attr('fill-opacity', 0.3);



                  slopeArea.append('text')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '12px')
                    .style('text-anchor', 'start')
                    .text(city_object.name);

                  slopeAreaWindow.append('text')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '12px')
                    .style('text-anchor', 'start')
                    .text(city_object.name);

                  slopeAreaWindow.append('text')
                    .attr('x', 0)
                    .attr('y', 15)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '8px')
                    .style('text-anchor', 'start')
                    .attr('color', 'grey')
                    .attr('font-weight', 'bold')
                    .text('Casos no período: '+(evolution_city_limited.length >= window_analysis ? (city_object.slope_y2-city_object.slope_y1) : city_object.value));
                  

                  slopeArea.append('text')
                    .attr('x', 0)
                    .attr('y', 15)
                    .attr('font-family', 'Helvetica')
                    .attr('font-size', '8px')
                    .style('text-anchor', 'start')
                    .attr('color', 'grey')
                    .attr('font-weight', 'bold')
                    .text('Casos acumulados: '+city_object.value);
                  

                });

            pie_multiple
              .selectAll('allLabels')
              .data(data_ready)
              .enter().append('g')
                .attr('class', 'arc')
                .attr('transform', 'translate('+width_graph*multiplier/2+','+height_graph*multiplier/2+')')
              .append('text')
                .text((d, i) => knn_cases[i].name)
                .attr('font-family', 'Helvetica')
                .attr('font-size', '8px')
                .attr('transform', function(d) {
                    var pos = labelOuterArc.centroid(d);
                    var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                    return 'translate(' + pos + ')';
                })
                .style('text-anchor', function(d) {
                    var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                    return (midangle < Math.PI ? 'start' : 'end')
                });

            function arcs(data0, data1) {
              var arcs0 = pie(data0),
                  arcs1 = pie(data1),
                  i = -1,
                  arc;
              while (++i < n) {
                arc = arcs0[i];
                arc.innerRadius = innerRadius;
                arc.outerRadius = outerRadius;
                arc.next = arcs1[i];
              }
              return arcs0;
            }

            chart.select('.aggregatedArea').selectAll("*").remove();


            let aggregatedArea = chart.select('.aggregatedArea')
              .append('g')
                .attr('transform', 'translate(55, -30)');

            let aggregatedAreaWindow = aggregatedArea.append('g')
              .attr('transform', 'translate(0, '+(height_graph*2 + 50)+')');

            let aggregated_xScaleEvolucao = d3.scaleTime()
                .domain([first_date, last_date])
                .range([0, width_graph*2]);

            let aggregated_xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m"))            
                .scale(aggregated_xScaleEvolucao)
                .ticks(5);
            

            let aggregated_yScaleEvolucao = d3.scaleLinear()
              .domain([0, d3.max(all_union[0], d => d.value)])
              .range([height_graph*2, 0]);

            let aggregated_line = d3.line()
                .x((d, i) => aggregated_xScaleEvolucao(d.date))
                .y(d => aggregated_yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            let aggregated_area = d3.area()
                .x((d, i) => aggregated_xScaleEvolucao(d.date))
                .y0(height_graph*2)
                .y1((d, i) => aggregated_yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            aggregatedArea.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,'+aggregated_yScaleEvolucao(0)+')')
                .call(aggregated_xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 8)
                .attr('font-family', 'Helvetica');

            aggregatedAreaWindow.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,'+aggregated_yScaleEvolucao(0)+')')
                .call(aggregated_xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 8)
                .attr('font-family', 'Helvetica');

            let new_union = [];
            for( let j = 0; j < union[0].length; ++j ) {
              new_union.push({date: union[0][j].date, value: union[0][j].value});
              new_union[j].value = union[0][j].value-(union[0][0].value-union[1][0].value);
            }


            aggregatedArea.append('path')
                .attr('class', 'line_real')
                .attr('d', aggregated_line(union[0]))
                .attr('stroke', '#ff4f4f')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            aggregatedArea.append('path')
                .attr('d', aggregated_area(union[0]))
                .attr('stroke', 'none')
                .attr('fill', '#ff4f4f')
                .attr('fill-opacity', 0.3);

            aggregatedArea.append('path')
                .attr('class', 'line_real')
                .attr('d', aggregated_line(union[1]))
                .attr('stroke', '#000000')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            aggregatedArea.append('path')
                .attr('d', aggregated_area(union[1]))
                .attr('stroke', 'none')
                .attr('fill', "#000000")
                .attr('fill-opacity', 0.3);

            aggregatedAreaWindow.append('path')
                .attr('class', 'line_real')
                .attr('d', aggregated_line(new_union))
                .attr('stroke', '#ff4f4f')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            aggregatedAreaWindow.append('path')
                .attr('d', aggregated_area(new_union))
                .attr('stroke', 'none')
                .attr('fill', '#ff4f4f')
                .attr('fill-opacity', 0.3);

            aggregatedAreaWindow.append('path')
                .attr('class', 'line_real')
                .attr('d', aggregated_line(union[1]))
                .attr('stroke', '#000000')
                .attr('stroke-width', 1.2)
                .attr('fill', 'none');

            aggregatedAreaWindow.append('path')
                .attr('d', aggregated_area(union[1]))
                .attr('stroke', 'none')
                .attr('fill', "#000000")
                .attr('fill-opacity', 0.3);    

            aggregatedArea.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '12px')
              .style('text-anchor', 'start')
              .text('Casos agregados para a região (- '+description+')');

            aggregatedAreaWindow.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '12px')
              .style('text-anchor', 'start')
              .text('Casos agregados para a região (- '+description+')');

            aggregatedAreaWindow.append('text')
              .attr('x', 0)
              .attr('y', 15)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '8px')
              .style('text-anchor', 'start')
              .attr('color', 'grey')
              .attr('font-weight', 'bold')
              .text('Casos no período: '+(union[0].length > 0 ? 
                  union[0].length >= window_analysis ? (union[0][union[0].length-1].value-union[0][0].value) : union[0][union[0].length-1].value

                  : 0));

            aggregatedArea.append('text')
              .attr('x', 0)
              .attr('y', 15)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '8px')
              .style('text-anchor', 'start')
              .attr('color', 'grey')
              .attr('font-weight', 'bold')
              .text('Casos acumulados: '+(union[0].length > 0 ? union[0][union[0].length-1].value : 0));  









            /***********
          
              DRAW THE CITY

            *********/

            let city_object = {
              name: description,
              value: thisSlope[2],
              slope_y1: thisSlope[1],
              slope_y2: thisSlope[2],

            };
            
            let slopeArea = chart.select('.slopeArea')
              .append('g')
                .attr('transform', 'translate(-5, -30)');

            let slopeAreaWindow = slopeArea.append('g')
              .attr('transform', 'translate(0, '+(height_graph*2 + 50)+')');

            let acc = null;
            let new_c = null;
            let new_acc = [];
            if( evolution_city_limited.length > 0 ) {

              let dateBefore = new Date();
              dateBefore.setTime(day.getTime() - (24*60*60*1000)*(window_analysis+1));  

              acc = [{date: evolution_city_limited[0].date, value: +evolution_city_limited[0].casos}];
              new_c = [{date: evolution_city_limited[0].date, value: +evolution_city_limited[0].casos - (+getCasesBefore(evolution_city, dateBefore))}];

              for( let j = 1; j < evolution_city_limited.length; ++j ) {
                acc.push({date: evolution_city_limited[j].date, value: +evolution_city_limited[j].casos});
                new_c.push({date: evolution_city_limited[j].date, value: (+evolution_city_limited[j].casos) - (+evolution_city_limited[j-1].casos)});
              }  
              
              for( let j = 0; j < acc.length; ++j ) {
                new_acc.push({date: acc[j].date, value: acc[j].value});
                new_acc[j].value = acc[j].value-(acc[0].value-new_c[0].value);
              }

            } 

             let neighbors_xScaleEvolucao = d3.scaleTime()
                .domain([first_date, last_date])
                .range([0, width_graph*2]);

            let neighbors_xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m"))            
                .scale(neighbors_xScaleEvolucao)
                .ticks(5);

            // console.log('MAX UNION: ', d3.max(all_union[0], d => d.value));
            // console.log('MAX EVOLUTION: ',d3.max(evolution_city, d => +d.casos));


            let neighbors_yScaleEvolucao = d3.scaleLinear()
              .domain([0, d3.max(all_union[0], d => d.value)])
              .range([height_graph*2, 0]);

            let neighbors_line = d3.line()
                .x((d, i) => neighbors_xScaleEvolucao(d.date))
                .y(d => neighbors_yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            let neighbors_area = d3.area()
                .x((d, i) => neighbors_xScaleEvolucao(d.date))
                .y0(height_graph*2)
                .y1((d, i) => neighbors_yScaleEvolucao(d.value))
                .curve(d3.curveCardinal.tension(0.5));


            let neighbors_yScaleEvolucao_new = d3.scaleLinear()
              .domain([0, d3.max(all_union[1], d => d.value)])
              .range([height_graph*2, 0]);

            let neighbors_line_new = d3.line()
                .x((d, i) => neighbors_xScaleEvolucao(d.date))
                .y(d => neighbors_yScaleEvolucao_new(d.value))
                .curve(d3.curveCardinal.tension(0.5));

            let neighbors_area_new = d3.area()
                .x((d, i) => neighbors_xScaleEvolucao(d.date))
                .y0(height_graph*2)
                .y1((d, i) => neighbors_yScaleEvolucao_new(d.value))
                .curve(d3.curveCardinal.tension(0.5));


            slopeArea.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                .call(neighbors_xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 8)
                .attr('font-family', 'Helvetica');

            slopeAreaWindow.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,'+neighbors_yScaleEvolucao(0)+')')
                .call(neighbors_xAxisEvolucao)
              .selectAll('text')
                .attr('font-size', 0)
                .attr('font-family', 'Helvetica');
            

            if( evolution_city_limited.length > 0 ) {
              slopeArea.append('path')
                  .attr('class', 'line_real')
                  .attr('d', neighbors_line(acc))
                  .attr('stroke', '#ff4f4f')
                  .attr('stroke-width', 1.2)
                  .attr('fill', 'none');

              slopeArea.append('path')
                  .attr('d', neighbors_area(acc))
                  .attr('stroke', 'none')
                  .attr('fill', '#ff4f4f')
                  .attr('fill-opacity', 0.3);

              slopeArea.append('path')
                  .attr('class', 'line_real')
                  .attr('d', neighbors_line(new_c))
                  .attr('stroke', '#000000')
                  .attr('stroke-width', 1.2)
                  .attr('fill', 'none');

              slopeArea.append('path')
                  .attr('d', neighbors_area(new_c))
                  .attr('stroke', 'none')
                  .attr('fill', "#000000")
                  .attr('fill-opacity', 0.3);

              slopeAreaWindow.append('path')
                  .attr('class', 'line_real')
                  .attr('d', neighbors_line(new_acc))
                  .attr('stroke', '#ff4f4f')
                  .attr('stroke-width', 1.2)
                  .attr('fill', 'none');

              slopeAreaWindow.append('path')
                  .attr('d', neighbors_area(new_acc))
                  .attr('stroke', 'none')
                  .attr('fill', '#ff4f4f')
                  .attr('fill-opacity', 0.3);

              slopeAreaWindow.append('path')
                  .attr('class', 'line_real')
                  .attr('d', neighbors_line(new_c))
                  .attr('stroke', '#000000')
                  .attr('stroke-width', 1.2)
                  .attr('fill', 'none');

              slopeAreaWindow.append('path')
                  .attr('d', neighbors_area(new_c))
                  .attr('stroke', 'none')
                  .attr('fill', "#000000")
                  .attr('fill-opacity', 0.3);
            }

            

            slopeArea.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '12px')
              .style('text-anchor', 'start')
              .text(city_object.name);

            slopeAreaWindow.append('text')
              .attr('x', 0)
              .attr('y', 0)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '12px')
              .style('text-anchor', 'start')
              .text(city_object.name);

            slopeAreaWindow.append('text')
              .attr('x', 0)
              .attr('y', 15)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '8px')
              .style('text-anchor', 'start')
              .attr('color', 'grey')
              .attr('font-weight', 'bold')
              .text('Casos no período: '+(evolution_city_limited.length >= window_analysis ? (city_object.slope_y2 - city_object.slope_y1) : city_object.value));

            slopeArea.append('text')
              .attr('x', 0)
              .attr('y', 15)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '8px')
              .style('text-anchor', 'start')
              .attr('color', 'grey')
              .attr('font-weight', 'bold')
              .text('Casos acumulados: '+city_object.value);




            if( union[0].length == 0 && (thisSlope[2] == 1 || thisSlope[2] == 0) ) { // stop when there is no neighborhood and number of cases in the city is 1
              document.getElementById('decreaseDay').disabled = true;
            }

          // } else
          //   alert('cidade com zero casos HAHAHAHAHAHA');
          
        }

        function wrap(text, width) {
          text.each(function() {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
              }
            }
          });
        }


        function prepareRiskAnalysis(store) {
            let geoJson = store.geoJSON;
            let evolucao = store.evolucao;

            for (var i = 0; i < evolucao.length; i++) {
                evolucao[i].evolucao = +evolucao[i].evolucao;
                evolucao[i].casos_dia = +evolucao[i].casos_dia;

                let date_string = evolucao[i].data.split('/');
                let day = +date_string[0];

                let month = map_month[date_string[1]];

                let date = new Date(2020, month-1, day);

                evolucao[i].date = date;
            }

            firstDayAnalysis = evolucao[0].date;
            lastDayAnalysis = evolucao[evolucao.length-1].date;

            var margin = {
              top: 5,
              right: 10,
              bottom: 5,
              left: 10
            },
            twidth = 900 - margin.left - margin.right,
            theight = 600 - margin.top - margin.bottom;


            // let legends = d3.select("#statisticalCharts")
            //       .attr("width", twidth + margin.left + margin.right)
            //   .attr("height", theight + margin.top + margin.bottom)
            //   .append("g")
            //   .attr("transform", "translate(" + margin.left + "," + (margin.top - 30) + ")");

            let chart = d3.select("#cityRisk")
                .attr("width", '100%')
                .attr("height", '100%')
                .attr('viewBox','0 0 '+Math.min(width,height) +' '+600 )
                .attr('preserveAspectRatio','xMinYMin')
              .append("g")
                .attr("transform",  "translate(" + margin.left + "," + (margin.top) + ")");

            let principal = chart.append('g')
              .attr('class', 'principal')
              .attr('transform', 'translate(0,0)');

            title_g = chart.append('g')
                .attr('transform', 'translate(0,0)');

            chart.append('g')
              .attr('class', 'slopeArea')
              .attr('transform', 'translate(380,200)');

            chart.append('g')
              .attr('class', 'aggregatedArea')
              .attr('transform', 'translate(0, 200)');

            let windowvis = chart.append('g')
              .attr('class', 'windowvis')
              .attr('transform', 'translate(5,'+(theight-20)+' )');

            general_xScaleEvolucao = d3.scaleTime()
                .domain([firstDayAnalysis, lastDayAnalysis])
                .range([0, twidth-160]);

            let xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m"))            
                .scale(general_xScaleEvolucao)
                .ticks(10);

            windowvis.append('g')
                .style('stroke-width', 0.8)
                .attr('transform', 'translate(0,0)')
                .call(xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 8)
                .attr('font-family', 'Helvetica');

            dayAnalysis = new Date(lastDayAnalysis.getTime());
            
            let temp = new Date();
            temp.setTime(lastDayAnalysis.getTime() - (24*60*60*1000)*window_analysis);

            windowvis.append('rect')
              .attr('class', 'window-rect')
              .attr('x', general_xScaleEvolucao(temp))
              .attr('width', general_xScaleEvolucao(lastDayAnalysis)-general_xScaleEvolucao(temp))
              .attr('y', -11)
              .attr('height', 10)
              .style('fill', '#34abeb')
              .style('stroke', '#0099eb');



            // let legend = chart.append('g')
            //     .attr('class', 'legend')
            //     .attr('transform', 'translate(550,0)')
            //   .append('text')
            //     .attr('y', 0)
            //     .attr('dy', 15)
            //     .attr('transform', 'translate(0,'+(margin.top*5)+')')
            //     .attr('font-family', 'Helvetica')
            //     .attr('font-size', '10px')
            //     .attr('text-align', 'justify')
            //     .text('* O risco de contaminação é obtido considerando a curva de crescimento da vizinhança e da própria cidade. Cidades com risco maior de contaminação possuem vizinhança com curva crescente de contaminação, além de poderem apresentar esse mesmo padrão. Para calcular a taxa de risco, os 10 últimos dias foram utilizados.')
            //     .call(wrap, 160);


            title_g.append('text')
              .attr('x', (twidth)/2 - 80)
              .attr('y', 20)
              .attr('font-family', 'Helvetica')
              .attr('font-size', '16px')
              .style('text-anchor', 'middle')
              .text('Análise Visual do Risco de Contaminação*')

            return [chart, firstDayAnalysis, lastDayAnalysis];
        }

        function drawStatisticalCharts(store) {
            let geoJson = store.geoJSON;
            let evolucao = store.evolucao;

            for (var i = 0; i < evolucao.length; i++) {
                evolucao[i].evolucao = +evolucao[i].evolucao;
                evolucao[i].casos_dia = +evolucao[i].casos_dia;

                let date_string = evolucao[i].data.split('/');
                let day = +date_string[0];

                let month = map_month[date_string[1]];

                let date = new Date(2020, month-1, day);

                evolucao[i].date = date;
            }

            firstDayAnalysis = evolucao[0].date;
            lastDayAnalysis = evolucao[evolucao.length-1].date;

            var margin = {
              top: 100,
              right: 80,
              bottom: 30,
              left: 60
            },
            twidth = 900 - margin.left - margin.right,
            theight = 500 - margin.top - margin.bottom;


            // let legends = d3.select("#statisticalCharts")
            //       .attr("width", twidth + margin.left + margin.right)
            //   .attr("height", theight + margin.top + margin.bottom)
            //   .append("g")
            //   .attr("transform", "translate(" + margin.left + "," + (margin.top - 30) + ")");

            let legends = d3.select("#statisticalCharts")
                .attr("width", '100%')
                .attr("height", '100%')
                .attr('viewBox','0 0 '+Math.min(width,height) +' '+500 )
                .attr('preserveAspectRatio','xMinYMin')
              .append("g")
                .attr("transform",  "translate(" + margin.left + "," + (margin.top - 30) + ")");

            g_evolucao = legends.append('g')
                .attr('transform', 'translate(0,0)');


            let height_graph = 300;
            let width_graph = 650;

            let yScaleEvolucao = d3.scaleLinear()
                .domain([0, d3.max(evolucao, d => d.evolucao)])
                .range([height_graph, 0]);

            let yAxisEvolucao = d3.axisLeft()
                .scale(yScaleEvolucao)
                .ticks(5);

            g_evolucao.append('g')
                .style('stroke-width', 1.5)
                .attr('transform', 'translate(0,'+yScaleEvolucao(d3.max(evolucao, d => d.evolucao))+')')
                .call(yAxisEvolucao)
              .selectAll('text')
                .attr('font-size', 16)
                .attr('font-family', 'Helvetica');


            let xScaleEvolucao = d3.scaleTime()
                .domain([evolucao[0].date, evolucao[evolucao.length-1].date])
                .range([0, width_graph]);

            let xAxisEvolucao = d3.axisBottom()
                .tickFormat(d3.timeFormat("%d-%m-%Y"))            
                .scale(xScaleEvolucao);

            g_evolucao.append('g')
                .style('stroke-width', 1.5)
                .attr('transform', 'translate(0,'+yScaleEvolucao(0)+')')
                .call(xAxisEvolucao)
              .selectAll("text")
                .attr('font-size', 12)
                .attr('font-family', 'Helvetica')
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-65)");

            let line_evolucao = d3.line()
                .x((d, i) => xScaleEvolucao(d.date))
                .y(d => yScaleEvolucao(d.evolucao))
                .curve(d3.curveCardinal.tension(0.5));

            let area_evolucao = d3.area()
                .x((d, i) => xScaleEvolucao(d.date))
                .y0(height_graph)
                .y1((d, i) => yScaleEvolucao(d.evolucao))
                .curve(d3.curveCardinal.tension(0.5));

            g_evolucao.append('path')
                .attr('class', 'line_real')
                .attr('d', line_evolucao(evolucao))
                .attr('stroke', '#ffab52')
                .attr('stroke-width', 2)
                .attr('fill', 'none');

            g_evolucao.append('path')
                .attr('d', area_evolucao(evolucao))
                .attr('stroke', 'none')
                .attr('fill', '#ffab52')
                .attr('fill-opacity', 0.3);


            // draw new cases per day
            let line_novos = d3.line()
                .x((d, i) => xScaleEvolucao(d.date) )
                .y(d => yScaleEvolucao(d.casos_dia))
                .curve(d3.curveCardinal.tension(0.5));

            let area_novos = d3.area()
                .x((d, i) => xScaleEvolucao(d.date))
                .y0(height_graph)
                .y1((d, i) => yScaleEvolucao(d.casos_dia))
                .curve(d3.curveCardinal.tension(0.5));

            g_evolucao.append('path')
                .attr('class', 'line_real')
                .attr('d', line_novos(evolucao))
                .attr('stroke', '#ff5252')
                .attr('stroke-width', 2)
                .attr('fill', 'none');

            g_evolucao.append('path')
                .attr('d', area_novos(evolucao))
                .attr('stroke', 'none')
                .attr('fill', '#ff5252')
                .attr('fill-opacity', 0.3);


            let cases = [];


            let array_evolucao = [];
            for( let i = 0; i < evolucao.length; ++i ) {
              array_evolucao.push({date: evolucao[i].date, value: yScaleEvolucao(evolucao[i].evolucao)});
            }
            cases.push({name:'evolucao', values: array_evolucao});

            
            array_evolucao = [];
            for( let i = 0; i < evolucao.length; ++i ) {
              array_evolucao.push({date: evolucao[i].date, value: yScaleEvolucao(evolucao[i].casos_dia)});
            }
            cases.push({name:'casos_dia', values: array_evolucao});


            // drawing legends

            g_evolucao.append('circle')
                .attr('cx', 30)
                .attr('cy', 5)
                .attr('r', 5)
                .style('fill', '#ffab52')
                .style('stroke', 'none');


            g_evolucao.append('circle')
                .attr('cx', 30)
                .attr('cy', 25)
                .attr('r', 5)
                .style('fill', '#ff5252')
                .style('stroke', 'none');


            g_evolucao.append('text')
                .attr('x', 40)
                .attr('y', 10)
                .attr('font-size', 16)
                .attr('font-family', 'Helvetica')
                .text('Casos confirmados');

            g_evolucao.append('text')
                .attr('x', 40)
                .attr('y', 30)
                .attr('font-size', 16)
                .attr('font-family', 'Helvetica')
                .text('Novos casos');


            var focus = legends.append("g")
                .attr("class", "focus")
                .style("display", "none");

            focus.append("rect")
                .attr("class", "tooltip2")
                .attr("width", 150)
                .attr("height", 70)
                .attr("x", 10)
                .attr("y", -22)
                .attr("rx", 4)
                .attr("ry", 4);

            focus.append("text")
                .attr("class", "tooltip-date")
                .attr("x", 18)
                .attr("y", -2);

            focus.append('line')
              .attr('class', 'tooltip-line')
              .attr('x1', 0)
              .attr('x2', 0)
              .attr('y1', yScaleEvolucao(d3.max(evolucao, d => d.evolucao))-margin.top)
              .attr('y2', yScaleEvolucao(0)-margin.top)
              .style('fill', 'none')
              .style('stroke', '#aaa');


            focus.append("text")
                .attr("x", 18)
                .attr("y", 18)
                .text("Confirmados:");

            focus.append("text")
                .attr("x", 18)
                .attr("y", 38)
                .text("Novos casos:");

            focus.append("text")
                .attr("class", "tooltip-confirmados")
                .attr("x", 105)
                .attr("y", 18);

            focus.append("text")
                .attr("class", "tooltip-likes")
                .attr("x", 105)
                .attr("y", 38);

            legends.append("rect")
                .attr("class", "overlay")
                .attr("width", twidth)
                .attr("height", theight)
                .on("mouseover", function() { focus.style("display", null); })
                .on("mouseout", function() { focus.style("display", "none"); })
                .on("mousemove", mousemove);
            
            let bisectDate = d3.bisector(function(d) { return d.date; }).left;

            function mousemove() {
                var x0 = xScaleEvolucao.invert(d3.mouse(this)[0]),
                    i = bisectDate(evolucao, x0, 1),
                    d0 = evolucao[i - 1],
                    d1 = evolucao[i];

                if( d0 != undefined && d1 != undefined ) {
                  let d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                      
                  focus.select('.tooltip-line').attr('x1', xScaleEvolucao(d.date)-15);
                  focus.select('.tooltip-line').attr('x2', xScaleEvolucao(d.date)-15);
                  focus.attr("transform", "translate(" + 15 + "," + 100 + ")");
                  focus.select(".tooltip-date").text(d3.timeFormat("%d/%m/%y")(d.date));
                  focus.select(".tooltip-likes").text(d.casos_dia);
                  focus.select('.tooltip-confirmados').text(d.evolucao);
                }
            }
        }

        function drawMapReal(geoJSON) {
            let config = getMapConfig('#map-covid');
            let projection = getMapProjection(config, geoJSON);

            configMapReal = config;
            projectionMapReal = projection;
            geoJson = geoJSON;
           drawBaseMapReal(config.container, geoJSON.features, projection, geoJSON, null);
        }

        function drawMapRealColor(geoJSON) {
            let config = getMapConfig('#map-covid-color');
            let projection = getMapProjection(config, geoJSON);

            configMapRealColor = config;
            projectionMapRealColor = projection;
            geoJsonColor = geoJSON;
           drawBaseMapRealColor(config.container, geoJSON.features, projection, geoJSON, null);
        }

        function drawMapRealHull(geoJSON) {
            let config = getMapConfig('#map-covid-hull');
            let projection = getMapProjection(config, geoJSON);

            configMapRealHull = config;
            projectionMapRealHull = projection;
            geoJsonHull = geoJSON;
           drawBaseMapHull(config.container, geoJSON.features, projection, geoJSON, null);
        }



        function drawMapRealDanger(geoJSON) {
            let config = getMapConfig('#map-covid-danger');
            let projection = getMapProjection(config, geoJSON);

            configMapRealDanger = config;
            projectionMapRealDanger = projection;
            geoJsonDanger = geoJSON;
            drawBaseMapRealDanger(config.container, geoJSON.features, projection, geoJSON, null);
        }

        function drawMapGoogleTrends(container, countries, projection, geoJson, color, symptom) {

            let path = d3.geoPath()
                .projection(projection);

            let paths = container.selectAll('path')
              .data(countries, d => d.id);

            paths.exit().remove();

            container.selectAll('path').style('fill-opacity', 0);

            paths.enter().append('path')
                .attr('d', d => { return path(d); })
                .style('stroke', '#ccc')
                .style('stroke-width', 1)
                .style('fill-opacity', 0)
                // .transition()
                // .duration(2000)
                //     .style('fill-opacity', 0)                    
                .transition()
                .duration(1000)
                    .style('fill', color)
                    .style('fill-opacity', (d, j) => { 
                        let value = 0;

                        for( let i = 0; i < subsetGoogleTrendsMap.length; i++) {
                            if( subsetGoogleTrendsMap[i].Cidade.trim().replace(/[^\x00-\x7F]/g, "") == d.properties.name.trim().replace(/[^\x00-\x7F]/g, "") ) {
                                value = subsetGoogleTrendsMap[i][symptom];
                                break;
                            }
                        }

                        let opacity =  value == 0 ? 0 : value/d3.max(subsetGoogleTrendsMap, v => v[symptom]);

                        return opacity;
                    });
        }

        function addUnespDescription(g) {


          g.append('image')
            .attr('x', 0)
            .attr('y', -70)
            .attr('xlink:href', 'unesp.svg')
            .attr('width', 120)
            .attr('height', 50)

          g.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('text-anchor', 'start')
            // .attr('class', 'title')
            .style('font-size', '14px')
            .style('font-family', 'Helvetica')
            .text('UNIVERSIDADE ESTADUAL PAULISTA')
          g.append('text')
            .attr('x', 0)
            .attr('y', 17)
            .attr('text-anchor', 'start')
            .style('font-size', '14px')
            .style('font-family', 'Helvetica')
            .text('"JÚLIO MESQUITA FILHO"')

          g.append('text')
            .attr('x', 0)
            .attr('y', 40)
            .attr('text-anchor', 'start')
            .style('font-size', '13px')
            .style('font-family', 'Helvetica')
            .text('Departamento de Matemática e Computação - DMC')

          g.append('text')
            .attr('x', 0)
            .attr('y', 56)
            .attr('text-anchor', 'start')
            .style('font-size', '13px')
            .style('font-family', 'Helvetica')
            .text('Campus de Presidente Prudente')

        }

        function updateLegend(container, color) {
          d3.select('.g_density').selectAll("*").remove();
          let g_density = container.select('.g_density');

          let scaleWidth = 300;
          // let colorScale = d3.scaleSequential(d3.interpolateGreys)
          //     .domain([0, scaleWidth*2]);

          // let bars = g_density.selectAll(".bars")
          //     .data(d3.range(scaleWidth*2), function(d) { return d; })
          //   .enter().append("rect")
          //     .attr("class", "bars")
          //     .attr("x", d => d/2.0)
          //     .attr("y", 0)
          //     .attr("height", 20)
          //     .attr("width", 1)
          //     .style("fill", function(d, i ) { return colorTrends; })//return colorScale(d); })
          //     .style('fill-opacity', function(d, i) { return d/(scaleWidth*2); })
          //     .style('stroke-opacity', 0);

          let percents = [0, 0.2, 0.5, 0.8, 1];
          let step = 35;
          for( let i = 0; i < percents.length; ++i ) {
            g_density.append('rect')
              .attr('x', i*35 + i*step)
              .attr('y', 0)
              .attr('width', 30)
              .attr('height', 30)
              .style('fill', colorTrends)
              .style('fill-opacity', percents[i])
              .style('stroke', 'black');

             g_density.append('text')
              .attr('x', (i+1)*35 + i*step)
              .attr('y', 20)
              .attr('text-anchor', 'start')
              .style('font-family', 'Helvetica')
              .style('font-size', 14)
              .text((percents[i]*100)+'%');
          }

          

          g_density.append('text')
            .attr('x', 0)
            .attr('y', 45)
            .attr('text-anchor', 'start')
            .style('font-family', 'Helvetica')
            .style('font-size', 14)
            .text('Sem interesse');

          g_density.append('text')
            .attr('x', 2*(percents.length)*step - step)
            .attr('y', 45)
            .attr('text-anchor', 'end')
            .style('font-family', 'Helvetica')
            .style('font-size', 14)
            .text('Maior interesse');

          g_density.append('text')
            .attr('x', scaleWidth/2)
            .attr('y', -8)
            .attr('text-anchor', 'middle')
            .style('font-family', 'Helvetica')
            .style('font-size', 16)
            .text('INTERESSE* NO SINTOMA');



          g_density.append('text')
            .attr('x', 0)
            .attr('y', 70)
            .attr('text-anchor', 'start')
            .style('font-family', 'Helvetica')
            .style('font-size', 10)
            .text('*Interesse no sintoma em relação à maior ocorrência de busca de um termo .');
          g_density.append('text')
            .attr('x', 0)
            .attr('y', 80)
            .attr('text-anchor', 'start')
            .style('font-family', 'Helvetica')
            .style('font-size', 10)
            .text('Cores mais escuras indicam maior ocorrência de busca.');

          // Intesse no sistema relativo ao pico de popularidade de um termo.
          // Cores mais intensas indicam maior popularidade.
        }

        function drawGoogleTrendsLegend(container) {
            // container.select('.twitter_colorscale')
            //     .selectAll('*')
            //     .transition()
            //     .duration(2000)
            //         .style('fill-opacity', 0);

            container.append("text")
              .attr('x', 805)
              .attr('y', 15)
              .attr('text-anchor', 'middle')
              .style('font-family', 'Helvetica')
              .style('font-size', 12)
              .text('Clique no círculo para')

            container.append("text")
              .attr('x', 805)
              .attr('y', 35)
              .attr('text-anchor', 'middle')
              .style('font-family', 'Helvetica')
              .style('font-size', 12)
              .text('selecionar o sintoma')

            


            let trends_legend = container.append('g')  
                .attr('class', 'trends_legend')
                .attr('transform', 'translate(750, 50)');

            let googleTrends = googleTrendsMap.columns.slice(2, 7);

            for( let i = 0; i < googleTrends.length; i++ ) {

                trends_legend.append('circle')
                    .attr('cx', 0)
                    .attr('cy', i * 30 + 10)
                    .attr('r', 7)
                    .style('fill', termTrends == googleTrends[i] ? colors(googleTrends[i]) : 'gray')
                    .on('click', function() {
                        colorTrends = colors(googleTrends[i]);
                        termTrends = googleTrends[i];

                        trends_legend.selectAll('circle').style('fill', 'gray');                      
                        d3.select(this).style('fill', colorTrends);
                        updateLegend(container, colorTrends)
                        drawGoogleTrends(colors(googleTrends[i]), googleTrends[i]);
                    });


                trends_legend.append('text')
                    .attr('x',  12)
                    .attr('y', i * 30 + 5 + 10)
                    .style('font-family', 'Helvetica')
            .style('font-size', 14)
                    .text(googleTrends[i]);
            }

            // trends_legend.append('text')
            //     .attr('x', -7)
            //     .attr('y', 10)
            //     .text('Google Trends');

            trends_legend.append('rect')
                .attr('x', -20)
                .attr('y', -10)
                .attr('width', 150)
                .attr('height', 180)
                .style('stroke', 'black')
                .style('fill', 'none');
        }

        function drawGoogleTrends(color, symptom) {
            let config = getMapConfig("#map-google");
            let projection = getMapProjection(config, geoJson);

            drawMapGoogleTrends(config.container, geoJson.features, projection, geoJson, color, symptom);
        }

        function groupByCityName(data) {
            let result = data.reduce((result, d) => {
                let currentDest = result[d.cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "")] || {
                    'cidade': d.cidade,
                    'lat': +d.lat,
                    'long': +d.long,
                    'Count': 0
                };

                currentDest.Count += 1;
                
                result[d.cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "")] = currentDest;
                return result;
            }, {});

            result = Object.keys(result).map(key => result[key]);
            return result;
        }

        function drawSubsetTweets(tweets, store, update, operation) {
            let geoJson = store.geoJSON;
            let evolucao = store.evolucao;


            let config = getMapConfig('#map-twitter');
            let projection = getMapProjection(config, geoJson);
            let container = config.container;
            let states = geoJson.features;
            let g_legend = null;


            let groupedCitiesName = groupByCityName(tweets);
            mapCityCount = {};
            for( let i = 0; i < groupedCitiesName.length; i++ ) {
              mapCityCount[groupedCitiesName[i].cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "")] = groupedCitiesName[i].Count;
            }

            if( !update ) {
                let path = d3.geoPath()
                    .projection(projection);
      
                let paths = container.selectAll('path')
                  .data(states, d => d.id);
      
                paths.exit().remove();
                paths.enter().append('path')
                    .attr('d', d => { return path(d); })
                    .style('stroke', '#ccc')
                    .style('stroke-width', 1)
                    .style('fill-opacity', 0)
                    .on('click', d => {

                      // if( showingTooltip ) {
                      //   tooltip.transition()
                      //       .duration(500)
                      //       .style('opacity', 0);
                      // } else {
                      //   tooltip.transition()
                      //       .duration(200)
                      //       .style('opacity', .9);

                        

                        let name = d.properties.name.replace(/[^\x00-\x7F]/g, "");

                        let value = name in mapCityCount ? mapCityCount[d.properties.name.replace(/[^\x00-\x7F]/g, "")] : 0;
                        // for (var i = 0; i < tweets.length; i++) {
                        //     let cityName = tweets[i]['cidade'].split('-')[0].replace(/[^\x00-\x7F]/g, "");
                        //     if( cityName.trim() == name.trim() ) {
                        //         value++;
                        //     }
                        // }
                        tooltip.html("<p>"+d.properties.name+"</p>"+
                                    "<p>"+value+" tweet(s).</p>")
                            .style('left', (d3.event.pageX)+'px')
                            .style('top', (d3.event.pageY - 28)+'px');



                        // console.log('value: '+mapCityCount[d.properties.name.replace(/[^\x00-\x7F]/g, "")]);
                        // console.log(d.properties.name.replace(/[^\x00-\x7F]/g, ""));
                        // console.log(mapCityCount)
                        let s = document.getElementById('tooltip').style;
                        s.opacity = 1;
                        function fade() {
                          (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                        }
                        fade();
                      // }
                      // showingTooltip = !showingTooltip;
                       
                    })
                    // .on('mouseout', d => {
                    //     tooltip.transition()
                    //         .duration(500)
                    //         .style('opacity', 0);
                    // });


                let g_description = container.append('g')
                    .attr('transform', 'translate(10,650)');  
                addUnespDescription(g_description);




                //  g_density.append('text')
                //   .attr('x', 0)
                //   .attr('y', -5)
                //   .attr('text-anchor', 'start')
                //   .style('font-family', 'Times New Roman')
                //   .style('font', '14px')
                //   .text('Número de tweets');


                // let elements = [1, 5, 15];

                // for( let i = 0; i < elements.length; ++i ) {

                //   for( let j = 0; j < elements[i]; ++j ) {
                //     g_density.append('rect')
                //       .attr('x', i*50)
                //       .attr('y', 0)
                //       .attr('width', 45)
                //       .attr('height', 45)
                //       .style('fill', 'red')
                //       .style('fill-opacity', 0.1)
                //       .style('stroke', 'none');
                //   }

                //   g_density.append('text')
                //     .attr('x', i*50 + 45/2)
                //     .attr('y', 63)
                //     .attr('text-anchor', 'middle')
                //     .style('font-family', 'Times New Roman')
                //     .style('font', '14px')
                //     .text(elements[i] == 15 ? '+15' : elements[i]);


                // }


                




                // let scaleWidth = 300;
                // let colorScale = d3.scaleSequential(d3.interpolateReds)
                //     .domain([0, scaleWidth*2]);

                // let bars = g_density.selectAll(".bars")
                //     .data(d3.range(scaleWidth*2), function(d) { return d; })
                //   .enter().append("rect")
                //     .attr("class", "bars")
                //     .attr("x", d => d/2.0)
                //     .attr("y", 0)
                //     .attr("height", 20)
                //     .attr("width", 1)
                //     .style("fill", function(d, i ) { return colorScale(d); })
                //     .style('stroke-opacity', 0);

                // g_density.append('text')
                //   .attr('x', 0)
                //   .attr('y', 25)
                //   .attr('text-anchor', 'start')
                //   .style('font-family', 'Times New Roman')
                //   .style('font', '14px')
                //   .text('max');

                
            }

            container.select('.legend_twitter').remove();
            g_legend = container.append('g')
              .attr('class', 'legend_twitter')
              .attr('transform', 'translate(10, 30)');

            let g = null;
            if( !update ) {
                g = container.append('g')
                    .attr('class', 'tweets_geo');
            } else {
                g = container.select('.tweets_geo');
            }

            let sp_latlong = [-23.533773, -46.625290];


            // console.log('meus tweets');
            // console.log(tweets);

            // let tweetsById = groupByCityId(tweets);
            // console.log('tweets by id');
            // console.log(tweetsById);



            // console.log('min: '+d3.min(tweetsById, d => d.Count));
            // console.log('max: '+d3.max(tweetsById, d => d.Count));

            let groupedCities = groupByCity(tweets);
            
            // groupedCitiesName = groupedCitiesName.filter(d => d.cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "") != "São Paulo".replace(/[^\x00-\x7F]/g, ""))


            
            if( !aggregate ) {

              let scaleArea = d3.scaleLog()
                  .domain([1, (d3.max(groupedCitiesName, d => +d.Count))])
                  .range([5, 20]);
               
              let scaleArea2 = d3.scaleLog()
                  .domain([1, Math.pow(Math.round(scaleArea.invert(20/2)), 2)])
                  .range([5, 20]);


              let scaleLegend = Math.pow(Math.round(scaleArea.invert(20/2)), 2) > d3.max(groupedCitiesName, d => +d.Count) ?
                                scaleArea2 : scaleArea;

              let circle = g.selectAll('circle')
                  .data(groupedCitiesName, d => d.cidade.split('-')[0].replace(/[^\x00-\x7F]/g, ""));

              // TODO: fix lat long SP!
              for (var i = 0; i < groupedCitiesName.length; i++) {
                if( groupedCitiesName[i].cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "") == 'So Paulo' ) {
                  groupedCitiesName[i].lat = sp_latlong[0];
                  groupedCitiesName[i].long = sp_latlong[1];
                  break;
                }
              }

              circle.exit().remove();

              circle.enter().append('circle')    
                  .attr('cx', d => projection([d.long, d.lat])[0]
                  // { 
                  //     if( Math.floor(Math.random() * 2) + 1 ) {
                  //         let jitter_x = Math.floor(Math.random() * 10) + 1;
                  //         return projection([d.long, d.lat])[0] + jitter_x;
                  //     } else {
                  //         let jitter_x = -(Math.floor(Math.random() * 10) + 1);
                  //         return projection([d.long, d.lat])[0] + jitter_x;
                  //     }
                  // }
                  )
                  .attr('cy', d => projection([d.long, d.lat])[1]
                  // { 
                  //     if( Math.floor(Math.random() * 2) + 1 ) {
                  //         let jitter_y = Math.floor(Math.random() * 10) + 1;
                  //         return projection([d.long, d.lat])[1] + jitter_y;
                  //     } else {
                  //         let jitter_y = -(Math.floor(Math.random() * 10) + 1);
                  //         return projection([d.long, d.lat])[1] + jitter_y;
                  //     }
                  // }
                  )
                  .style('fill', '#eb4034')
                  .style('fill-opacity', 0.3)
                  .style('stroke','#eb4034' )
                  .style('stroke-opacity', 0.8)
                  .on('click', (d, i) => {
                      // d3.select('#tweet')
                      //     .html('<p>'+d.text+'</p>')

                      tooltip.html("<p>"+d.cidade.split('-')[0]+"</p>"+
                                  "<p>"+d.Count+" tweet(s).</p>")
                          .style('left', (d3.event.pageX)+'px')
                          .style('top', (d3.event.pageY - 28)+'px');

                      let s = document.getElementById('tooltip').style;
                      s.opacity = 1;
                      function fade() {
                        (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                      }
                      fade();
                  })
                .merge(circle)
                  .transition()
                  .duration(500)
                      // .attr('r', 5)
                    .attr('r', d => {
                      // console.log(d.Count+ ", "+Math.log(d.Count)+": "+scaleArea(Math.log(d.Count)));
                      return scaleArea((d.Count));
                    });

              // if( !update ) {

                  let max = 4;
                  let step = (d3.max(groupedCitiesName, d => +d.Count) - d3.min(groupedCitiesName, d => +d.Count))/max;


                  let numbers = [...new Set(groupedCitiesName.map(d =>  +d.Count))].sort(function compare(a, b) {
                      if (a < b) return -1;
                      if (a > b) return 1;
                      return 0;
                  });
                
                  let numbers_legend = [1, Math.round(scaleArea.invert((20+5)/2)), Math.pow(Math.round(scaleArea.invert((20+5)/2)),2)];



                  g_legend.append('text')
                    .attr('x', d => 10 - scaleLegend(numbers_legend[0]))
                    .attr('y', d => 20)
                    .attr('text-anchor', 'start')
                    .style('font-size', 16)
                    .style('font-family', 'Helvetica')
                    .text('NÚMERO DE TWEETS*'); 

                  g_legend.append('circle')
                    .attr('cx', d => 10)
                    .attr('cy', d => 50)
                    .attr('r', scaleLegend(numbers_legend[0]))
                    .style('fill', '#eb4034')
                    .style('fill-opacity', 0.2)
                    .style('stroke', '#eb4034')
                    .style('stroke-opacity', 0.8); 

                  g_legend.append('text')
                      .attr('x', d => 10)
                      .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                      .attr('text-anchor', 'middle')
                      .style('font-size', 14)
                      .style('font-family', 'Helvetica')
                      .text(numbers_legend[0]); 


                  g_legend.append('text')
                    .attr('x', d => 5)
                    .attr('y', d => 120)
                    .attr('text-anchor', 'start')
                    .style('font-size', 10)
                    .style('font-family', 'Helvetica')
                    .text('*Dimensionamento dos círculos:'); 

                  g_legend.append('text')
                    .attr('x', d => 5)
                    .attr('y', d => 130)
                    .attr('text-anchor', 'start')
                    .style('font-size', 10)
                    .style('font-family', 'Helvetica')
                    .text('Escala logarítmica.'); 

                  let r_before = scaleLegend(numbers_legend[0]);
                  let x_before = 10;
                  
                  for( let  i = 1; i < numbers_legend.length; i++ ) {

                      let r = scaleLegend(numbers_legend[i]);
                      g_legend.append('circle')
                          .attr('cx', d => x_before + r_before + 20 + r)
                          .attr('cy', d => 50)
                          .attr('r', r)
                          .style('fill', '#eb4034')
                          .style('fill-opacity', 0.2)
                          .style('stroke', '#eb4034')
                          .style('stroke-opacity', 0.8);  

                      g_legend.append('text')
                          .attr('x', d => x_before + r_before + 20 + r)
                          .attr('y', d => 50 + scaleLegend(numbers_legend[numbers_legend.length-1]) + 20)
                          .attr('text-anchor', 'middle')
                          .style('font-size', 14)
                          .style('font-family', 'Helvetica')
                          .text(numbers_legend[i]);

                      r_before = r;
                      x_before = x_before + r_before + 20 + r;

                  }
              // }
            } else {
                
                for( let i = 0; i < groupedCitiesName.length; ++i ) {
                  let city = groupedCitiesName[i].cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "");
                  if( city in cityQuantity ) {
                    cityQuantity[city].count += operation*groupedCitiesName[i].Count;
                  }
                }

                let elementsToDraw = Object.keys(cityQuantity).map(key => cityQuantity[key]);

                let scaleArea = d3.scaleLog()
                    .domain([1, maxAggregateTweets])
                    .range([5, 25]);

                let circle = g.selectAll('circle')
                    .data(elementsToDraw, d => d.cidade.split('-')[0].replace(/[^\x00-\x7F]/g, ""));

                
                circle.exit().remove();

                circle.enter().append('circle')    
                    .attr('cx', d => { return projection([d.lat, d.long])[0]; }
                    )
                    .attr('cy', d => { return projection([d.lat, d.long])[1]; }
                    )
                    .style('fill', '#eb4034')
                    .style('fill-opacity', 0.1)
                    .style('stroke','#eb4034' )
                    .style('stroke-opacity', 0.8)
                    .on('click', (d, i) => {

                        tooltip.html("<p>"+d.cidade.split('-')[0]+"</p>"+
                                    "<p>"+d.Count+" tweet(s).</p>")
                            .style('left', (d3.event.pageX)+'px')
                            .style('top', (d3.event.pageY - 28)+'px');

                        let s = document.getElementById('tooltip').style;
                        s.opacity = 1;
                        function fade() {
                          (s.opacity-=.05) < 0 ? s.opacity = 0 : setTimeout(fade,400)
                        }
                        fade();
                    })
                  .merge(circle)
                    .transition()
                    .duration(500)
                        // .attr('r', 5)
                      .attr('r', d => {
                        if(d.count == 0 ) return 0;
                        // console.log(d.count+" "+scaleArea(d.count));
                        return scaleArea((d.count));
                      });

                    let numbers_legend = [1, Math.round(scaleArea.invert((20+5)/2)), maxAggregateTweets];



                    g_legend.append('text')
                      .attr('x', d => 10 - scaleArea(numbers_legend[0]))
                      .attr('y', d => 20)
                      .attr('text-anchor', 'start')
                      .style('font-size', 16)
                      .style('font-family', 'Helvetica')
                      .text('NÚMERO DE TWEETS*'); 

                    g_legend.append('circle')
                      .attr('cx', d => 10)
                      .attr('cy', d => 50)
                      .attr('r', scaleArea(numbers_legend[0]))
                      .style('fill', '#eb4034')
                      .style('fill-opacity', 0.2)
                      .style('stroke', '#eb4034')
                      .style('stroke-opacity', 0.8); 

                    g_legend.append('text')
                        .attr('x', d => 10)
                        .attr('y', d => 50 + scaleArea(numbers_legend[numbers_legend.length-1]) + 20)
                        .attr('text-anchor', 'middle')
                        .style('font-size', 14)
                        .style('font-family', 'Helvetica')
                        .text(numbers_legend[0]); 


                    g_legend.append('text')
                      .attr('x', d => 5)
                      .attr('y', d => 120)
                      .attr('text-anchor', 'start')
                      .style('font-size', 10)
                      .style('font-family', 'Helvetica')
                      .text('*Dimensionamento dos círculos:'); 

                    g_legend.append('text')
                      .attr('x', d => 5)
                      .attr('y', d => 130)
                      .attr('text-anchor', 'start')
                      .style('font-size', 10)
                      .style('font-family', 'Helvetica')
                      .text('Escala logarítmica.'); 

                    let r_before = scaleArea(numbers_legend[0]);
                    let x_before = 10;
                    
                    for( let  i = 1; i < numbers_legend.length; i++ ) {

                        let r = scaleArea(numbers_legend[i]);
                        g_legend.append('circle')
                            .attr('cx', d => x_before + r_before + 20 + r)
                            .attr('cy', d => 50)
                            .attr('r', r)
                            .style('fill', '#eb4034')
                            .style('fill-opacity', 0.2)
                            .style('stroke', '#eb4034')
                            .style('stroke-opacity', 0.8);  

                        g_legend.append('text')
                            .attr('x', d => x_before + r_before + 20 + r)
                            .attr('y', d => 50 + scaleArea(numbers_legend[numbers_legend.length-1]) + 20)
                            .attr('text-anchor', 'middle')
                            .style('font-size', 14)
                            .style('font-family', 'Helvetica')
                            .text(numbers_legend[i]);

                        r_before = r;
                        x_before = x_before + r_before + 20 + r;

                    }   
            }
        }

        function compareDates(tDate, date) {
          let a = tDate.split(" ")[0];

          return date == a.split("-")[2]+"/"+ number_to_month[+a.split("-")[1] - 1];
        }

        function filter_city_date(cities, dates, tweets, casosByCity) {

          let filtered_twitter = [];
          let filtered_cases = [];

          for( let i = 0; i < cities.length; ++i ) {
            let city = cities[i].split("-")[0].replace(/[^\x00-\x7F]/g, "");
            for( let j = 0; j < dates.length; ++j ) {
              let date = dates[j];


              filtered_twitter = filtered_twitter.concat(
                  tweets.filter(d => {
                      return d.cidade.split("-")[0].replace(/[^\x00-\x7F]/g, "") == city &&
                      compareDates(d.date, date);
                  })
              );

              filtered_cases = filtered_cases.concat(
                  casosByCity.filter(d => {

                    return d.cidade.replace(/[^\x00-\x7F]/g, "") == city &&
                    d.data == date;
                  })
              );
            } 
          }


          return [filtered_twitter, filtered_cases];
        }

        function groupAccumulateCitiesDate(data) {
          let result = data.reduce((result, d) => {

                let currentDest = result[d.cidade.replace(/[^\x00-\x7F]/g, "")] || {
                    'cidade': d.cidade,
                    'lat': +d.lat,
                    'long': +d.long,
                    'count': 0
                };

                currentDest.count += +d.count;
                result[d.cidade.replace(/[^\x00-\x7F]/g, "")] = currentDest;
                return result;
            }, {});

            result = Object.keys(result).map(key => result[key]);
            return result;
        }

        function groupCitiesDate(data) {
          let result = data.reduce((result, d) => {

                let a = d.date.split(" ")[0];
                let date = a.split("-")[2]+"/"+ number_to_month[+a.split("-")[1] - 1];


                let currentDest = result[d.cidade.replace(/[^\x00-\x7F]/g, "")+"_"+date] || {
                    'cidade': d.cidade,
                    'lat': +d.lat,
                    'long': +d.long,
                    'diasfrom': +d.diasfrom,
                    'count': 0,
                    'first_tweet': +d.diasfrom,
                    'data': date
                };

                currentDest.count += 1;
                result[d.cidade.replace(/[^\x00-\x7F]/g, "")+"_"+date] = currentDest;
                return result;
            }, {});

            result = Object.keys(result).map(key => result[key]);
            return result;
        }

        function groupCities(data) {
            let result = data.reduce((result, d) => {

                let currentDest = result[d.cidade.replace(/[^\x00-\x7F]/g, "")] || {
                    'cityid': d.cityid,
                    'cidade': d.cidade,
                    'lat': +d.lat,
                    'long': +d.long,
                    'diasfrom': +d.diasfrom,
                    'count': 0,
                    'first_tweet': +d.diasfrom
                };

                currentDest.count += 1;
                result[d.cidade.replace(/[^\x00-\x7F]/g, "")] = currentDest;
                return result;
            }, {});

            result = Object.keys(result).map(key => result[key]);
            return result;
        }

        function showData() {

            let tweets = store.tweets;
            // cityById = groupByCity(tweets);

            // let last_date = new Date(2020, 1, 27);
            // for( let i = 0; i < tweets.length; ++i ) {
            //   let temp = tweets[i].date.split(" ")[0].split("-");
            //   let date = new Date(+temp[0], +temp[1] - 1, +temp[2]);

            //   tweets[i].date_object = date;
            //   tweets[i].lat = +tweets[i].lat;
            //   tweets[i].long = +tweets[i].long;
            //   tweets[i].id = i;

            //   if( last_date < tweets[i].date_object ) {
            //       last_date = tweets[i].date_object;
            //   }
            // }          
            // let subsetTwitter = tweets.filter(d => d.date_object.getDay() == last_date.getDay() &&
            //                                        d.date_object.getMonth() == last_date.getMonth() &&
            //                                        d.date_object.getYear() == last_date.getYear());


            // let distinctDatesTwitter = [...new Set(tweets.map(d => d.date.split(" ")[0]))];
            // document.getElementById('dateTwitter').max = distinctDatesTwitter.length-1;
            // document.getElementById('dateTwitter').value = distinctDatesTwitter.length-1;
            // twitterDayMax = distinctDatesTwitter.length-1;
            // twitterDay = distinctDatesTwitter.length-1;
            // document.getElementById('twitter-front').disabled = true;          




            let distinctDates = [...new Set(casosByCity.map(d => d.data))];
            // document.getElementById('realProgression').max = distinctDates.length-1;
            // document.getElementById('realProgression').value = 0;// distinctDates.length-1;
            progressionDayMax = distinctDates.length-1;
            progressionDay = 0//distinctDates.length-1;
            // document.getElementById('progression-front').disabled = true;
            // document.getElementById('progression-back').disabled = true;   

            // document.getElementById('realProgressionColor').max = distinctDates.length-1;
            // document.getElementById('realProgressionColor').value = 0;// distinctDates.length-1;
            // progressionDayMaxColor = distinctDates.length-1;
            // progressionDayColor = 0//distinctDates.length-1;
            // // document.getElementById('progression-front').disabled = true;
            // document.getElementById('progression-back-color').disabled = true;          

            // document.getElementById('realProgressionHull').max = distinctDates.length-1;
            // document.getElementById('realProgressionHull').value = 0;// distinctDates.length-1;
            // progressionDayMaxHull = distinctDates.length-1;
            // progressionDayHull = 0//distinctDates.length-1;
            // // document.getElementById('progression-front').disabled = true;
            // document.getElementById('progression-back-hull').disabled = true;  

            // document.getElementById('realProgressionDanger').max = distinctDates.length-1;
            // document.getElementById('realProgressionDanger').value = 0;// distinctDates.length-1;
            // progressionDayMaxDanger = distinctDates.length-1;
            // progressionDayDanger = 0//distinctDates.length-1;
            // // document.getElementById('progression-front').disabled = true;
            // document.getElementById('progression-back-danger').disabled = true;      

       

            // let maxValue = [...new Set(googleTrendsMap.map(d => d.ate))].length-1;
            // document.getElementById('dateGoogleTrends').max = maxValue;
            // document.getElementById('dateGoogleTrends').value = maxValue;
            // googleDayMax = maxValue;
            // googleDay = maxValue;
            // document.getElementById('google-front').disabled = true;

            console.log('knn_cities');
            console.log(knn_cities);

            drawMapReal(store.geoJSON);
            risk_data = prepareRiskAnalysis(store);
            // drawMapRealColor(store.geoJSON);
            // drawMapRealHull(store.geoJSON);
            // drawMapRealDanger(store.geoJSON);
            // drawStatisticalCharts(store);

            // // must be after drawStatisticalCHarts: it uses firstDayAnalysis
            // allTweets = tweets;

            // drawSubsetTweets(subsetTwitter, store, false, 0);
            // drawStatisticalChartsTwitter(tweets);
            
            // let city = "São Paulo";
            // let filtered = tweets.filter(d => d.cidade.split("-")[0].replace(/[^\x00-\x7F]/g, "") == city.replace(/[^\x00-\x7F]/g, ""));
            // let cases = casosByCity.filter(d => d.cidade.replace(/[^\x00-\x7F]/g, "") == city.replace(/[^\x00-\x7F]/g, ""));

            // // drawStatisticalChartsTwitterCity(filtered, cases);
            // drawStatisticalChartsTwitterCity(tweets, casosByCity);

            // let sp_cities = [];
            // for( let i = 0; i < store.geoJSON.features.length; i++ ) {
            //   sp_cities.push(store.geoJSON.features[i].properties.name);
            // }

            // let all_dates = new Set();
            // for( let i = 0; i < casosByCity.length; ++i ) {
            //   all_dates.add(casosByCity[i].data);
            // }

            // all_dates = [...all_dates];

            // let tmp = {};

            // tweets.forEach(function(item){
            //    var d = item.date_object;
            //    var yr = d.getFullYear(),
            //        mo = d.getMonth(),
            //        day = d.getDate();
            //    tmp[yr +'' + mo + '' + day] = item; // will overwrite prior same date
            // });

            // let results = Object.keys(tmp).map(key => tmp[key]);
            // console.log('tweets');
            // console.log(tweets);

            // console.log('sp_cities');
            // console.log(sp_cities);

            // console.log('all_dates');
            // console.log(all_dates);

            // results.sort(function compare(a, b) {
            //   let dateA = a.date_object;
            //   let dateB = b.date_object;
            //   return dateA - dateB;
            // });


            // let all_dates_twitter = new Set();
            // for( let i = 0; i < results.length; ++i ) {

            //   let temp = results[i].date.split(" ")[0].split("-");
            //   all_dates_twitter.add(temp[2]+"/"+(number_to_month[+(temp[1])-1]));
            // }

            // all_dates_twitter = [...all_dates_twitter];

            // console.log('results');
            // console.log(results);

            // cities = ["São Paulo", "Presidente Prudente"];
            // dates = ["15/mar", "17/mar", "22/mar", "05/abr"];
            // values = filter_city_date(cities, dates, tweets, casosByCity);


            // accumulated_days = [];

            // for( let i = 0; i < all_dates_twitter.length; ++i ) {
            //     let sliced_dates = all_dates_twitter.slice(i, i+1);

            //     let filtered_tweets = tweets.filter(d => {
            //       let a = d.date.split(" ")[0];
            //       let date = a.split("-")[2]+"/"+ number_to_month[+a.split("-")[1] - 1];
            //       return date == sliced_dates[0];
            //     });

            //     console.log('I have '+filtered_tweets.length+' tweets to look out  ('+i+')');
            //     let values_acc = filter_city_date(sp_cities, sliced_dates, filtered_tweets, casosByCity);
            //     console.log('filtered  ('+i+')');
            //     let acc_tweets = groupCitiesDate(values_acc[0]);
            //     console.log('Grouped ('+i+')');
            //     let acc_cases = values_acc[1];


            //     accumulated_days.push({
            //       tweets: acc_tweets,
            //       acc_cases: acc_cases,
            //       date: sliced_dates[0]
            //     });

            // }

            // console.log('accumulated_days');
            // console.log(accumulated_days);

            
            


            
            // accumulated_tweets = groupCities(values[0]);
            // console.log('values[0]');
            // console.log(values[0]);

            // console.log('accumulated_tweets');
            // console.log(accumulated_tweets);

            // accumulated_cases = values[1];
            // accumulated_tweets_city = groupCitiesDate(values[0]); 


            // max_casos = -1;
            // max_tweets = -1;


            // // max_casos = d3.max(accumulated_cases.filter(d => d.data == dates[dates.length-1]),
            // //                        d => +d.casos);
            // // max_tweets = d3.max(accumulated_tweets_city, d => +d.count);

            // // console.log('max_casos: '+max_casos);
            // // console.log('max_tweets: '+max_tweets);

            // // console.log('groupByCityDate');
            // // console.log(accumulated_tweets_city);
            // // console.log('accumulatedCities');
            // // console.log(agglomerated_tweets);

            // // drawMapAnalysis(accumulated_tweets_city.filter(d => d.data == dates[currentDate]), 
            // //                 accumulated_cases.filter(d => d.data == dates[currentDate]), 
            // //                 max_casos, max_tweets);



            // let temp = [];
            // for( let i = 0; i < accumulated_days.length; ++i ) {
            //     temp = temp.concat(accumulated_days[i].tweets);
            // }
            // let agglomerated_tweets = groupAccumulateCitiesDate(temp);


            // max_tweets = d3.max(agglomerated_tweets, d => +d.count);
            // max_casos = d3.max(accumulated_days[accumulated_days.length-1].acc_cases, d => +d.casos);
            // dates = all_dates_twitter;

            // console.log('max_casos: '+max_casos);
            // console.log('max_tweets: '+max_tweets);

            // console.log('accumulated_days[0].tweets');
            // console.log(accumulated_days[0].tweets);

            // console.log('accumulated_days[0].acc_cases');
            // console.log(accumulated_days[0].acc_cases);

            // console.log('accumulated_days')
            // console.log(accumulated_days)


            // drawMapAnalysis(accumulated_days[0].tweets, accumulated_days[0].acc_cases, max_casos, max_tweets);




           

            // let g_description = getMapConfig("#map-google").container.append('g')
            //     .attr('transform', 'translate(10,650)');   
            // addUnespDescription(g_description);


            // colorTrends = colors(googleTrendsMap.columns[2]);
            // termTrends = googleTrendsMap.columns[2];
            // drawGoogleTrendsLegend(getMapConfig("#map-google").container);

            // getMapConfig("#map-google").container.append('g')  
            //   .attr('class', 'g_density')
            //   .attr('transform', 'translate(10, 25)');

            // updateLegend(getMapConfig("#map-google").container, colors(googleTrendsMap.columns[2]));
            // drawGoogleTrends(colors(googleTrendsMap.columns[2]), googleTrendsMap.columns[2]);



            // drawMortalityRate();
        } 


        // document.getElementById('nextDate').addEventListener('click', function() {
        //   if( (currentDate < dates.length-1) ) {
        //     currentDate++;

        //     let temp = [];
        //     for( let i = 0; i <= currentDate; ++i ) {
        //         temp = temp.concat(accumulated_days[i].tweets);
        //     }
        //     let agglomerated_tweets = groupAccumulateCitiesDate(temp);


        //     // drawMapAnalysis(accumulated_tweets_city.filter(d => d.data == dates[currentDate]), 
        //     //                 accumulated_cases.filter(d => d.data == dates[currentDate]), 
        //     //                 max_casos, max_tweets);

        //     drawMapAnalysis(agglomerated_tweets, accumulated_days[currentDate].acc_cases, max_casos, max_tweets);
        //   }
        // }); 

        function groupByCity(data) {
            let result = data.reduce((result, d) => {
                let currentDest = result[d.cityid] || {
                    'cityid': d.cityid,
                    'cidade': d.cidade,
                    'lat': +d.lat,
                    'long': +d.long,
                    'diasfrom': +d.diasfrom,
                    'Count': 0,
                    'first_tweet': +d.diasfrom
                };

                currentDest.Count += 1;
                
                if( result[d.cityid] )
                    currentDest.first_tweet = Math.min(currentDest.first_tweet, result[d.cityid].first_tweet);
                result[d.cityid] = currentDest;
                return result;
            }, {});

            result = Object.keys(result).map(key => result[key]);
            return result;
        }

        function distanceTo(lat1, lon1, lat2, lon2) {
            let unit = 'K';
            let rlat1 = Math.PI*lat1/180;
            let rlat2 = Math.PI*lat2/180;
            let theta = lon1 - lon2;
            let rtheta = Math.PI*theta/180;
            let dist =
                Math.sin(rlat1)*Math.sin(rlat2) + Math.cos(rlat1)*
                Math.cos(rlat2)*Math.cos(rtheta);
            dist = Math.acos(dist);
            dist = dist*180/Math.PI;
            dist = dist*60*1.1515;

            switch (unit)
            {
                case 'K': //Kilometers -> default
                    return dist*1.609344;
                case 'N': //Nautical Miles 
                    return dist*0.8684;
                case 'M': //Miles
                    return dist;
            }

            return dist;
        }

         function getKNN(name) {
          let value = knn_cities[name];

          return value.knn;
        }

        function distance(c1, c2) {
          return Math.sqrt(Math.pow((c1[0]) - (c2[0]), 2.0) + Math.pow((c1[1]) - (c2[1]), 2.0));
        }

        function compute_knn(cities, k) {
          let reverse_knn = {};
          let temp_cities = Object.keys(cities).map(key => cities[key]);
          Object.keys(cities).forEach(function(key) {
              let value = cities[key];


              for( let i = 0; i < temp_cities.length; ++i ) {

                // temp_cities[i].temp_distance = distanceTo(value.centroid[0], value.centroid[1], temp_cities[i].centroid[0], temp_cities[i].centroid[1]);
                temp_cities[i].temp_distance = distance(value.centroid_xy, temp_cities[i].centroid_xy);
              }

              temp_cities.sort((a, b) => a.temp_distance-b.temp_distance);

              for( let i = 1; i <= k; ++i) {
                value.knn.push(temp_cities[i].name);
                if( !(temp_cities[i].name.replace(/[^\x00-\x7F]/g, "") in reverse_knn) ) {
                    reverse_knn[temp_cities[i].name.replace(/[^\x00-\x7F]/g, "")] = []
                }
                reverse_knn[temp_cities[i].name.replace(/[^\x00-\x7F]/g, "")].push(cities[key].name);
              }
          });

          return reverse_knn;
        }


        function loadData() {
            return Promise.all([
                d3.json('geo/sp.geo.json'),
                d3.csv('data/cases-sp-cities.csv'),
                d3.csv('data/evolucao_casos.csv') //,
                // d3.csv('data/geoMap.csv'),
                // d3.csv('data/all_tweets.csv')
            ]).then(datasets => {

                store.geoJSON = datasets[0];

                knn_cities = {};

                let config = getMapConfig('#map-covid');
                let projection = getMapProjection(config, store.geoJSON);


                for ( let i = 0; i < store.geoJSON.features.length; ++i ) {
                  names_cidades.push(store.geoJSON.features[i].properties.name);

                  let centroid = d3.geoCentroid(store.geoJSON.features[i]);

                  knn_cities[store.geoJSON.features[i].properties.name.replace(/[^\x00-\x7F]/g, "")] = {
                      name: store.geoJSON.features[i].properties.name,
                      centroid: centroid,
                      centroid_xy: [projection([+centroid[0], +centroid[1]])[0], projection([+centroid[0], +centroid[1]])[1]],
                      knn: [],
                      feature: store.geoJSON.features[i],
                      temp_distance: 0
                  }
                }
                buildDropDown(names_cidades);

                reversed_knn = compute_knn(knn_cities, kFirstLevel);

                casosByCity = datasets[1];
                store.evolucao = datasets[2];
                console.log('store.evolucao');
                console.log(store.evolucao);
                // googleTrendsMap = datasets[3];

                // store.tweets = datasets[4].filter(d => {

                //     let temp = d.date.split(" ")[0].split("-");
                //     let date = new Date(+temp[0], +temp[1] - 1, +temp[2]);
                //     // tweets[i].data = new Date(+temp[0], +temp[1] - 1, +temp[2]);

                //     return date >= new Date(2020, 1, 27);
                // });

                // cityid,cidade,lat,long,diasfrom,date,



                // cityQuantity = {};
                // for( let i = 0; i < store.geoJSON.features.length; ++i ) {

                //   cityQuantity[store.geoJSON.features[i].properties.name.replace(/[^\x00-\x7F]/g, "")] = {
                //       count: 0, 
                //       cidade: store.geoJSON.features[i].properties.name,
                //       lat: +d3.geoCentroid(store.geoJSON.features[i])[0],
                //       long: +d3.geoCentroid(store.geoJSON.features[i])[1] 
                //   };
                // }

                // for( let j = 0; j < store.tweets.length; ++j ) {
                //   if( store.tweets[j].cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "") in cityQuantity )
                //     cityQuantity[store.tweets[j].cidade.split('-')[0].replace(/[^\x00-\x7F]/g, "")].count += 1;                  
                // }


                // cityQuantityVector = Object.keys(cityQuantity).map(key => cityQuantity[key]).slice();
                // maxAggregateTweets = d3.max(cityQuantityVector, d => d.count);





                // mais tarde

                // let first_date = ""; 

                
                // let map_date = {};

                // let all_tweets_normalized = [];


                // for( let j = 0; j < store.tweets.length; ++j ) {
                //   // console.log("hello "+j);
                //   let date = store.tweets[j].date.split(" ")[0];

                //   console.log(first_date+" != "+date);
                //   if( first_date != date ) {

                //     console.log('entrei aqui');
                //     console.log(Object.keys(map_date).map(key => map_date[key]));
                //     first_date = date;
                    

                //     all_tweets_normalized = all_tweets_normalized.concat(Object.keys(map_date).map(key => map_date[key]));
                //     map_date = {};
                //     store.geoJSON.features.forEach(function(d, i) {
                //       let centroid = d3.geoCentroid(d);
                //       map_date[d.properties.name.replace(/[^\x00-\x7F]/g, "")] = {
                //         'cityid': i,
                //         'cidade': d.properties.name,
                //         'lat': +centroid[0],
                //         'long': +centroid[1],
                //         'Count': 0,
                //         'date': store.tweets[i].date
                //       }
                //     });
                //   }

                //   for( let i = 0; i < store.geoJSON.features.length; ++i ) {
                //     if( d3.geoContains(store.geoJSON.features[i], [+store.tweets[i].long, +store.tweets[i].lat]) ) {
                //       map_date[store.geoJSON.features[i].properties.name.replace(/[^\x00-\x7F]/g, "")].Count += 1;
                //       break;
                //     }
                //   } 
                  
                // }
                // console.log('all_tweets_normalized');
                // console.log(all_tweets_normalized);

                


                // for( let i = 0; i < polygons.length; ++i ) {
                //   console.log('Is '+store.tweets[0].cidade+' in '+polygons[i].properties.name+'? '+);
                //   // console.log(polygons[i]);
                //   console.log(d3.geoContains(polygons[i].geometry, [+store.tweets[0].lat, +store.tweets[0].long]))
                //   // console.log([+store.tweets[0].lat, +store.tweets[0].long]);
                //   // console.log(polygons[i]);
                //   // if( d3.geoContains(polygons[i], [+store.tweets[0].lat, +store.tweets[0].long]) ) {
                //   //     console.log("yes");
                //   // } else
                //   //   console.log('no');

                // }



                // store.geoJSON.features.forEach(function(d, i) {
                //   map_date[d.properties.name] =
                // });





                // console.log('map_date')
                // console.log(map_date);
                // console.log(Object.keys(map_date).map(key => map_date[key]));






                // store.geoJSON.features.forEach(function(d) {

                //     if( d3.geoContains(d, [+store.tweets[0].long, +store.tweets[0].lat]) ) {
                //       console.log("ACHEI");
                //       console.log(d);
                //       console.log(store.tweets);
                //     }else
                //       console.log("não achei")
                // });

                // let polygons = store.geoJSON.features;
                // for( let i = 0; i < polygons.length; ++i ) {
                //   console.log('Is '+store.tweets[0].cidade+' in '+polygons[i].properties.name+'? '+d3.geoContains(polygons[i], [+store.tweets[0].lat, +store.tweets[0].long]));
                //   // console.log(polygons[i]);
                //   console.log(d3.geoContains(polygons[i].geometry, [+store.tweets[0].lat, +store.tweets[0].long]))
                //   // console.log([+store.tweets[0].lat, +store.tweets[0].long]);
                //   // console.log(polygons[i]);
                //   // if( d3.geoContains(polygons[i], [+store.tweets[0].lat, +store.tweets[0].long]) ) {
                //   //     console.log("yes");
                //   // } else
                //   //   console.log('no');

                // }


                lastDate = new Date(2020, 0, 1);
                let temp = "";

                for( let i = 0; i < casosByCity.length; i++ ) {

                    let date_string = casosByCity[i].data.split('/');
                    let day = +date_string[0];

                    let month = map_month[date_string[1]];

                    let date = new Date(2020, month-1, day);
                    if( date > lastDate ) {
                        lastDate = date;
                    }

                    casosByCity[i].date = date;
                }

                // let googleTrendsMapLastDate = new Date(2020, 0, 1);


                // for( let i = 0; i < googleTrendsMap.length; ++i ) {
                //       let date_string = googleTrendsMap[i].ate.split('/');
                //       let day = +date_string[0];

                //       let month = map_month[date_string[1]];

                //       let date = new Date(2020, month-1, day);
                //       if( date > googleTrendsMapLastDate ) {
                //           googleTrendsMapLastDate = date;
                //           temp = googleTrendsMap[i].ate;
                //       }

                //       googleTrendsMap[i]['tosse'] = +googleTrendsMap[i]['tosse'];
                //       googleTrendsMap[i]['febre'] = +googleTrendsMap[i]['febre'];
                //       googleTrendsMap[i]['tosse seca'] = +googleTrendsMap[i]['tosse seca'];
                //       googleTrendsMap[i]['febre alta'] = +googleTrendsMap[i]['febre alta'];
                //       googleTrendsMap[i]['falta de ar'] = +googleTrendsMap[i]['falta de ar'];
                //       googleTrendsMap[i]['lat'] = +googleTrendsMap[i]['lat'];
                //       googleTrendsMap[i]['long'] = +googleTrendsMap[i]['long'];

                //       googleTrendsMap[i]['id'] = i;

                //       googleTrendsMap[i].date = date;
                //   }

                //   colors = d3.scaleOrdinal(d3.schemeCategory10)
                //     .domain(googleTrendsMap.columns.slice(2, 7));

                //   subsetGoogleTrendsMap = googleTrendsMap.filter(d => d.ate == temp);
                //   document.getElementById('progressionGoogleTrends').innerHTML = "Dia: "+temp.split('/')[0]+'/'+map_month_pt[temp.split('/')[1]]+'.';
                

                return store;
            })
        }

        function getMapConfig(map) {
            // let container = d3.select(map)
            //   .attr('width', width)
            //   .attr('height', height);


            let container = d3.select(map)
              .attr("width", '100%')
              .attr("height", '80%')
              .attr('viewBox','0 0 '+width+' '+height )
              .attr('preserveAspectRatio','xMinYMin');
              // .append("g")
              // .attr("transform",  "translate(" + margin.left + "," + (margin.top - 30) + ")")

                

            return {width, height, container};
        }

        function getMapProjection(config, geoJson) {
            let {width, height} = config;
            let projection = d3.geoMercator();

            var center = d3.geoCentroid(geoJson);
            var scale = 10;
            var offset = [width/2, height/2];
            projection = d3.geoMercator().scale(scale)
                .center(center)
                .translate(offset);

            let path = d3.geoPath()
                .projection(projection);

            var bounds = path.bounds(geoJson)
            var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
            var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
            var scale   = (hscale < vscale) ? hscale : vscale;
            var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                            height - (bounds[0][1] + bounds[1][1])/2];

            // new projection
            projection = d3.geoMercator().center(center)
                .scale(scale).translate(offset);

            store.mapProjection = projection;

            return projection;
        }

        //Initialize with the list of symbols
        let names_cidades = [];

        //Find the input search box
        let search = document.getElementById("searchCidade")

        //Find every item inside the dropdown
        let items = document.getElementsByClassName("dropdown-item")
        function buildDropDown(values) {
            let contents = []
            for (let name of values) {
            contents.push('<input type="button" class="dropdown-item" type="button" value="' + name + '"/>')
            }
            $('#menuItems').append(contents.join(""))

            //Hide the row that shows no items were found
            $('#empty').hide()
        }

        //Capture the event when user types into the search box
        // window.addEventListener('#searchCidade', function () {
        //     filter(search.value.trim().toLowerCase())
        // })

        document.getElementById('searchCidade').addEventListener('keyup', function() {
          filter(search.value.trim().toLowerCase())
        })

        //For every word entered by the user, check if the symbol starts with that word
        //If it does show the symbol, else hide it
        function filter(word) {
            let length = items.length
            let collection = []
            let hidden = 0
            for (let i = 0; i < length; i++) {
              if (items[i].value.toLowerCase().startsWith(word)) {
                  $(items[i]).show()
              }
              else {
                  $(items[i]).hide()
                  hidden++
              }
            }
            console.log('to aqui');

            //If all items are hidden, show the empty view
            if (hidden === length) {
            $('#empty').show()
            }
            else {
            $('#empty').hide()
            }
        }

        //If the user clicks on any item, set the title of the button as the text of the item
        $('#menuItems').on('click', '.dropdown-item', function(){
            $('#dropdown_cidades').text($(this)[0].value);
            $("#dropdown_cidades").dropdown('toggle');
            cityAnalysis = $(this)[0].value;
            dayAnalysis = new Date(lastDayAnalysis.getTime());
            addRiskMeasures(cityAnalysis.replace(/[^\x00-\x7F]/g, ""), cityAnalysis, dayAnalysis, window_analysis);


        })

        


        document.getElementById('decreaseDay').addEventListener('click', () => {

            if( dayAnalysis.getTime() === firstDayAnalysis.getTime() ) {
                document.getElementById('decreaseDay').disabled = true;
            } else {
                document.getElementById('increaseDay').disabled = false;
                dayAnalysis.setTime(dayAnalysis.getTime() - (24*60*60*1000)*1);
                addRiskMeasures(cityAnalysis.replace(/[^\x00-\x7F]/g, ""), cityAnalysis, dayAnalysis, window_analysis);
            }
        });

        document.getElementById('increaseDay').addEventListener('click', () => {

            if( dayAnalysis.getTime() === lastDayAnalysis.getTime() ) {
                document.getElementById('increaseDay').disabled = true;
            } else {
                document.getElementById('decreaseDay').disabled = false;
                dayAnalysis.setTime(dayAnalysis.getTime() + (24*60*60*1000)*1);
                addRiskMeasures(cityAnalysis.replace(/[^\x00-\x7F]/g, ""), cityAnalysis, dayAnalysis, window_analysis);
            }
        });



        function updateProgressionMap(value) {
            let countDifferent = 0;
            let targetDate = casosByCity[0].data;

            for (var i = 0; i < casosByCity.length; i++) {

                if( value == countDifferent ) {
                    targetDate = casosByCity[i].data;
                    break;
                }

                if( targetDate != casosByCity[i].data ) {
                    countDifferent += 1;
                    targetDate = casosByCity[i].data;
                }
            }

            let subset = casosByCity.filter(d => d.data == targetDate);
            drawBaseMapReal(configMapReal.container, geoJson.features, projectionMapReal, geoJson, subset, true);


            document.getElementById('titleProgression').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        }

        // document.getElementById('progression-front').addEventListener('click', () => {
        //   if( progressionDay < progressionDayMax ) {

        //     updateProgressionMap(++progressionDay);
        //     document.getElementById('progression-back').disabled = false;
        //     if( progressionDay == progressionDayMax )
        //         document.getElementById('progression-front').disabled = true;
        //   }
        // });

        // document.getElementById('progression-back').addEventListener('click', () => {
        //   if( progressionDay > 0 ) {
        //     updateProgressionMap(--progressionDay);
        //     document.getElementById('progression-front').disabled = false;
        //     if( progressionDay == 0 )
        //         document.getElementById('progression-back').disabled = true;
        //   } 
        // });



        function updateProgressionMapDanger(value) {
            let countDifferent = 0;
            let targetDate = casosByCity[0].data;

            for (var i = 0; i < casosByCity.length; i++) {

                if( value == countDifferent ) {
                    targetDate = casosByCity[i].data;
                    break;
                }

                if( targetDate != casosByCity[i].data ) {
                    countDifferent += 1;
                    targetDate = casosByCity[i].data;
                }
            }

            let subset = casosByCity.filter(d => d.data == targetDate);
            drawBaseMapRealDanger(configMapRealDanger.container, geoJsonDanger.features, projectionMapRealDanger, geoJsonDanger, subset, true);


            document.getElementById('titleProgressionDanger').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        }

        // document.getElementById('progression-front-danger').addEventListener('click', () => {
        //   if( progressionDayDanger < progressionDayMaxDanger ) {

            
        //     for( let i = 0; i < neighboring_cities_danger.length; ++i ) {
        //         previous_neighboring_danger_cities.push(neighboring_cities_danger[i]);
        //     }
            

        //     updateProgressionMapDanger(++progressionDayDanger);
        //     document.getElementById('progression-back-danger').disabled = false;
        //     if( progressionDayDanger == progressionDayMaxDanger )
        //         document.getElementById('progression-front-danger').disabled = true;
        //   }
        // });

        // document.getElementById('progression-back-danger').addEventListener('click', () => {
        //   if( progressionDayDanger > 0 ) {

        //     for( let i = 0; i < neighboring_cities_danger.length; ++i )
        //       previous_neighboring_danger_cities.pop();


        //     updateProgressionMapDanger(--progressionDayDanger);
        //     document.getElementById('progression-front-danger').disabled = false;
        //     if( progressionDayDanger == 0 )
        //         document.getElementById('progression-back-danger').disabled = true;
        //   } 
        // });


        // function updateProgressionMapColor(value) {
        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapRealColor(configMapRealColor.container, geoJsonColor.features, projectionMapRealColor, geoJsonColor, subset, true);


        //     document.getElementById('titleProgressionColor').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // }

        // document.getElementById('progression-front-color').addEventListener('click', () => {
        //   if( progressionDayColor < progressionDayMaxColor ) {

        //     for( let i = 0; i < neighboring_cities.length; ++i )
        //       previous_neighboring_cities.push(neighboring_cities[i]);

        //     updateProgressionMapColor(++progressionDayColor);
        //     document.getElementById('progression-back-color').disabled = false;
        //     if( progressionDayColor == progressionDayMaxColor )
        //         document.getElementById('progression-front-color').disabled = true;
        //   }
        // });

        // document.getElementById('progression-back-color').addEventListener('click', () => {
        //   if( progressionDayColor > 0 ) {

        //     for( let i = 0; i < neighboring_cities.length; ++i )
        //       previous_neighboring_cities.pop();

        //     updateProgressionMapColor(--progressionDayColor);
        //     document.getElementById('progression-front-color').disabled = false;
        //     if( progressionDayColor == 0 )
        //         document.getElementById('progression-back-color').disabled = true;
        //   } 
        // });

        // function updateProgressionMapHull(value) {
        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapHull(configMapRealHull.container, geoJsonHull.features, projectionMapRealHull, geoJsonHull, subset, true);


        //     document.getElementById('titleProgressionHull').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // }

        // document.getElementById('progression-front-hull').addEventListener('click', () => {
        //   if( progressionDayHull < progressionDayMaxHull ) {

        //     updateProgressionMapHull(++progressionDayHull);
        //     document.getElementById('progression-back-hull').disabled = false;
        //     if( progressionDayHull == progressionDayMaxHull )
        //         document.getElementById('progression-front-hull').disabled = true;
        //   }
        // });

        // document.getElementById('progression-back-hull').addEventListener('click', () => {
        //   if( progressionDayHull > 0 ) {

        //     updateProgressionMapHull(--progressionDayHull);
        //     document.getElementById('progression-front-hull').disabled = false;
        //     if( progressionDayHull == 0 )
        //         document.getElementById('progression-back-hull').disabled = true;
        //   } 
        // });


        // function isEqual(a, b) {

        //   a = a.split(" ")[0];
        //   b = b.split(" ")[0];

        //   a = a.split("-");
        //   b = b.split("-");


        //   return a[0] == b[0] && a[1] == b[1] && a[2] == b[2];
        // }

        // function updateTwitterMap(days, operation) {
        //     let one_day = 1000*60*60*24;
        //     let object = null;
        //     let date = 0;

        //     for( let i = 0; i < allTweets.length; ++i ) {

        //         let value = Math.round(allTweets[i].date_object-(new Date(2020, 2, 27)))/one_day;

        //         //if( value == days ) {

        //         if( allTweets[i].diasfrom == days ) {
        //             date = allTweets[i].date_object;
        //             object = allTweets[i];
        //             break;
        //         }
        //     }

        //     let subsetTwitter = allTweets.filter(d => isEqual(d.date, object.date));

        //     drawSubsetTweets(subsetTwitter, store, true, operation);
        //     document.getElementById('progressionTwitter').innerHTML = 'Dia: '+object.date.split(" ")[0].split("-")[2]+"/"+map_month_pt[number_to_month[+object.date.split(" ")[0].split("-")[1] - 1]];
        // }


        // document.getElementById('twitter-front').addEventListener('click', () => {
        //   if( twitterDay < twitterDayMax ) {
        //     if( !aggregate )
        //       ++twitterDay;
        //     updateTwitterMap(aggregate ? twitterDay+1 : twitterDay, 1);
            
        //      if( aggregate )
        //       ++twitterDay;


        //     document.getElementById('twitter-back').disabled = false;
        //     if( twitterDay == twitterDayMax )
        //         document.getElementById('twitter-front').disabled = true;

           
        //   }
        // });

        // document.getElementById('twitter-back').addEventListener('click', () => {
        //   if( twitterDay > 0 ) {
        //     if( !aggregate )
        //       --twitterDay;
        //     updateTwitterMap(twitterDay, -1);
        //     if( aggregate )
        //       --twitterDay;
        //     document.getElementById('twitter-front').disabled = false;
        //     if( twitterDay == 0 )
        //         document.getElementById('twitter-back').disabled = true;

            
        //   } 
        // });


        // function updateGoogleMap(value) {
        //   let countDifferent = 0;
        //   let targetDate = googleTrendsMap[0].ate;

        //   for (var i = 0; i < googleTrendsMap.length; i++) {

        //       if( value == countDifferent ) {
        //           targetDate = googleTrendsMap[i].ate;
        //           break;
        //       }

        //       if( targetDate != googleTrendsMap[i].ate ) {
        //           countDifferent += 1;
        //           targetDate = googleTrendsMap[i].ate;
        //       }
        //   }

        //   subsetGoogleTrendsMap = googleTrendsMap.filter(d => d.ate == targetDate);

        //   drawGoogleTrends(colorTrends, termTrends);
        //   document.getElementById('progressionGoogleTrends').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // }


        // document.getElementById('google-front').addEventListener('click', () => {
        //   if( googleDay < googleDayMax ) {
        //     updateGoogleMap(++googleDay);
        //     document.getElementById('google-back').disabled = false;
        //     if( googleDay == googleDayMax )
        //         document.getElementById('google-front').disabled = true;
        //   }
        // });

        // document.getElementById('google-back').addEventListener('click', () => {
        //   if( googleDay > 0 ) {
        //     updateGoogleMap(--googleDay);
        //     document.getElementById('google-front').disabled = false;
        //     if( googleDay == 0 )
        //         document.getElementById('google-back').disabled = true;
        //   } 
        // });



        // document.getElementById('dateGoogleTrends').addEventListener('input', function() {
        //     let value = this.value;
        //     googleDay = value;
        //     if( googleDay == 0 ) {
        //         document.getElementById('google-back').disabled = true; 
        //         document.getElementById('google-front').disabled = false; 
        //     } else if( googleDay == googleDayMax ) {
        //         document.getElementById('google-back').disabled = false; 
        //         document.getElementById('google-front').disabled = true; 
        //     } else {
        //         document.getElementById('google-back').disabled = false; 
        //         document.getElementById('google-front').disabled = false; 
        //     }

        //     let countDifferent = 0;
        //     let targetDate = googleTrendsMap[0].ate;

        //     for (var i = 0; i < googleTrendsMap.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = googleTrendsMap[i].ate;
        //             break;
        //         }

        //         if( targetDate != googleTrendsMap[i].ate ) {
        //             countDifferent += 1;
        //             targetDate = googleTrendsMap[i].ate;
        //         }
        //     }

        //     subsetGoogleTrendsMap = googleTrendsMap.filter(d => d.ate == targetDate);

        //     drawGoogleTrends(colorTrends, termTrends);
        //     document.getElementById('progressionGoogleTrends').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // });

        // document.getElementById('realProgression').addEventListener('input', function() {
        //     let value = this.value;
        //     progressionDay = value;
        //     if( progressionDay == 0 ) {
        //         document.getElementById('progression-back').disabled = true; 
        //         document.getElementById('progression-front').disabled = false; 
        //     } else if( progressionDay == progressionDayMax ) {
        //         document.getElementById('progression-back').disabled = false; 
        //         document.getElementById('progression-front').disabled = true; 
        //     } else {
        //         document.getElementById('progression-back').disabled = false; 
        //         document.getElementById('progression-front').disabled = false; 
        //     }


        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapReal(configMapReal.container, geoJson.features, projectionMapReal, geoJson, subset, true);


        //     document.getElementById('titleProgression').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // });


        // document.getElementById('realProgressionColor').addEventListener('input', function() {
        //     let value = this.value;
        //     progressionDayColor = value;
        //     if( progressionDayColor == 0 ) {
        //         document.getElementById('progression-back-color').disabled = true; 
        //         document.getElementById('progression-front-color').disabled = false; 
        //     } else if( progressionDayColor == progressionDayMaxColor ) {
        //         document.getElementById('progression-back-color').disabled = false; 
        //         document.getElementById('progression-front-color').disabled = true; 
        //     } else {
        //         document.getElementById('progression-back-color').disabled = false; 
        //         document.getElementById('progression-front-color').disabled = false; 
        //     }


        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapRealColor(configMapRealColor.container, geoJsonColor.features, projectionMapRealColor, geoJsonColor, subset, true);


        //     document.getElementById('titleProgressionColor').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // });


        // document.getElementById('realProgressionColor').addEventListener('input', function() {
        //     let value = this.value;
        //     progressionDayDanger = value;
        //     if( progressionDayDanger == 0 ) {
        //         document.getElementById('progression-back-danger').disabled = true; 
        //         document.getElementById('progression-front-danger').disabled = false; 
        //     } else if( progressionDayDanger == progressionDayMaxDanger ) {
        //         document.getElementById('progression-back-danger').disabled = false; 
        //         document.getElementById('progression-front-danger').disabled = true; 
        //     } else {
        //         document.getElementById('progression-back-danger').disabled = false; 
        //         document.getElementById('progression-front-danger').disabled = false; 
        //     }


        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapRealDanger(configMapRealDanger.container, geoJsonDanger.features, projectionMapRealDanger, geoJsonDanger, subset, true);


        //     document.getElementById('titleProgressionDanger').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // });


        // document.getElementById('realProgressionHull').addEventListener('input', function() {
        //     let value = this.value;
        //     progressionDayHull = value;
        //     if( progressionDayHull == 0 ) {
        //         document.getElementById('progression-back-hull').disabled = true; 
        //         document.getElementById('progression-front-hull').disabled = false; 
        //     } else if( progressionDayHull == progressionDayMaxHull ) {
        //         document.getElementById('progression-back-hull').disabled = false; 
        //         document.getElementById('progression-front-hull').disabled = true; 
        //     } else {
        //         document.getElementById('progression-back-hull').disabled = false; 
        //         document.getElementById('progression-front-hull').disabled = false; 
        //     }


        //     let countDifferent = 0;
        //     let targetDate = casosByCity[0].data;

        //     for (var i = 0; i < casosByCity.length; i++) {

        //         if( value == countDifferent ) {
        //             targetDate = casosByCity[i].data;
        //             break;
        //         }

        //         if( targetDate != casosByCity[i].data ) {
        //             countDifferent += 1;
        //             targetDate = casosByCity[i].data;
        //         }
        //     }

        //     let subset = casosByCity.filter(d => d.data == targetDate);
        //     drawBaseMapHull(configMapRealHull.container, geoJsonHull.features, projectionMapRealHull, geoJsonHull, subset, true);


        //     document.getElementById('titleProgressionHull').innerHTML = 'Dia: '+targetDate.split('/')[0]+'/'+map_month_pt[targetDate.split('/')[1]]+'.';
        // });

        // document.getElementById('dateTwitter').addEventListener('input', function() {
        //     let days = this.value;
        //     twitterDay = days;
        //     if( twitterDay == 0 ) {
        //         document.getElementById('twitter-back').disabled = true; 
        //         document.getElementById('twitter-front').disabled = false; 
        //     } else if( twitterDay == twitterDayMax ) {
        //         document.getElementById('twitter-back').disabled = false; 
        //         document.getElementById('twitter-front').disabled = true; 
        //     } else {
        //         document.getElementById('twitter-back').disabled = false; 
        //         document.getElementById('twitter-front').disabled = false; 
        //     }


        //     let one_day = 1000*60*60*24;
        //     let object = null;
        //     for( let i = 0; i < allTweets.length; ++i ) {

        //         let value = Math.round(allTweets[i].date_object-(new Date(2020, 1, 27)))/one_day;

        //         if( value == days ) {
        //             date = allTweets[i].date_object;
        //             object = allTweets[i];
        //             break;
        //         }
        //     }

        //     let subsetTwitter = allTweets.filter(d => d.date_object.getDay() == date.getDay() &&
        //                                          d.date_object.getMonth() == date.getMonth() &&
        //                                          d.date_object.getYear() == date.getYear());
        //     drawSubsetTweets(subsetTwitter, store, true);
        //     document.getElementById('progressionTwitter').innerHTML = 'Dia: '+object.date.split(" ")[0].split("-")[2]+"/"+
        //     map_month_pt[number_to_month[+object.date.split(" ")[0].split("-")[1] - 1]];
        // });



        // /*****CODE FOR ANIMATION******/
        // let max_days = 30;
        // let day_mapa = 1;
        
        // document.getElementById('proximo-dia').addEventListener('click', function() {
          
        //   day_mapa += 1;
        //   document.getElementById('dia-anterior').disabled = false;          
        //   document.getElementById('image-mapa').src = "data/mapas/image"+day_mapa+".jpeg";
        //   if( day_mapa == max_days ) {
        //     document.getElementById('proximo-dia').disabled = true;
            
        //   }
        // }); 

        // document.getElementById('dia-anterior').disabled = true;
        // document.getElementById('dia-anterior').addEventListener('click', function() {
        //   day_mapa -= 1;
                    
        //   document.getElementById('proximo-dia').disabled = false;
        //   document.getElementById('image-mapa').src = "data/mapas/image"+day_mapa+".jpeg";
        //   if( day_mapa == 1 ) {
        //     document.getElementById('dia-anterior').disabled = true;           
        //   }
        // }); 

        // /*****************************/
        
      </script>

        

      
      

      
      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

        

        
          
          <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
          
          <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
          
        

        
        
      

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
      

      
      
      <script>hljs.initHighlightingOnLoad();</script>
      

      
      
      
      
      
      
      <script>
        const search_config = {"indexURI":"index.json","minLength":1,"threshold":0.3};
        const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
        const content_type = {
          'post': "Posts",
          'project': "Projects",
          'publication' : "Publications",
          'talk' : "Talks"
          };
      </script>
      

      
      

      
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
        <div class="search-hit-content">
          <div class="search-hit-name">
            <a href="{{relpermalink}}">{{title}}</a>
            <div class="article-metadata search-hit-type">{{type}}</div>
            <p class="search-hit-description">{{snippet}}</p>
          </div>
        </div>
        </div>
      </script>
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
      

      
      

      
      

      
      
      
      
      
      
      
      
      
        
      
      
      
      
      <script src="/js/academic.min.96cf4c3dc37ea60dbbd03c13a455f1f7.js"></script>

      






    
    
    <div class="container">
      <footer class="site-footer">
    


    <p class="powered-by">
      
      <img src="unesp.svg" width="100" height="50" style="position: absolute; margin: auto; right: 0; left: 0;" /><br/>
      <strong>Faculdade de Ciências e Tecnologia - Câmpus de Presidente Prudente</strong><br/>
      Rua Roberto Simonsen, 305 - Centro Educacional - P. Prudente/SP - CEP 19060-900<br/>
      Telefone: (18) 3229-5388


     <!--  Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>. -->

      
      <span class="float-right" aria-hidden="true">
        <a href="#" class="back-to-top">
          <span class="button_icon">
            <i class="fas fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>
      
    </p>
  </footer>

    </div>
    

    
  <div id="modal" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Cite</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <pre><code class="tex hljs"></code></pre>
        </div>
        <div class="modal-footer">
          <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
            <i class="fas fa-copy"></i> Copy
          </a>
          <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
            <i class="fas fa-download"></i> Download
          </a>
          <div id="modal-error"></div>
        </div>
      </div>
    </div>
  </div>

  </body>
  </html>
